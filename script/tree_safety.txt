Require Export gap_ng_actor_ext_safety.

Module GAPNGBfsSafety (CMG : CommutativeMassGroup) <: 
       CommutativeMassGroup 
       with Definition gT := CMG.gT
       with Definition commutes := CMG.commutes.

Definition gT := CMG.gT.
Definition commutes := CMG.commutes.

Module GAPNGWithExtSafety := GAPNGExtSafety CMG.
Export GAPNGWithExtSafety.

Lemma bfs_net_ok_permutation : forall (T5 T' : T),
  bfs_net_ok T5 ->
  Permutation T5 T' ->
  bfs_net_ok T'.
Proof.
move => T5 T' H_ok.
move: T'.
elim: H_ok.
  move => T' H_pm.
  apply Permutation_nil in H_pm.
  rewrite H_pm.
  exact: bfs_ok_empty.
move => T' T0 H_ok IH H_red T'0 H_pm.
inversion H_red; subst.
apply (bfs_ok_red T'0 T'1); first by apply IH.
apply (bfs_netst_struct _ _ T'1 T'2) => //.
exact: (Permutation_trans H1).
Qed.

Definition project_churn_bfs_node (t5 : t) : s :=
mk_nd_churn (bfs_ident t5) (remove_except_new_fail (bfs_mbox t5)) (bfs_adj t5).

Definition project_churn_bfs := map project_churn_bfs_node.

Lemma project_churn_bfs_distr : forall (T5 T' : T), 
  project_churn_bfs (T5 ++ T') = project_churn_bfs T5 ++ project_churn_bfs T'.
Proof.
exact: map_app.
Qed.

Lemma project_churn_bfs_permutation : forall (T5 T' : T),
  Permutation T5 T' ->
  Permutation (project_churn_bfs T5) (project_churn_bfs T').
Proof.
elim => [|t5 T5 IH] T' H_pm.
  apply Permutation_nil in H_pm.
  by rewrite H_pm; apply Permutation_refl.
have H_in: In t5 T' by apply (Permutation_in _ H_pm); left.
have [T6 [T7 H_eq]] := In_split t5 T' H_in.
move: H_pm.
rewrite H_eq {H_eq} => H_pm.
rewrite project_churn_bfs_distr.
apply (Permutation_app_inv nil T5 T6 T7 t5) in H_pm.
apply IH in H_pm.
rewrite project_churn_bfs_distr in H_pm.
rewrite /= /project_churn_bfs_node.
set s5 := mk_nd_churn _ _ _.
have H_pm': Permutation (s5 :: project_churn_bfs T5) (s5 :: (project_churn_bfs T6 ++ project_churn_bfs T7)).
  exact: Permutation_cons.
apply Permutation_sym in H_pm'.
apply Permutation_sym.
move: H_pm'.
apply Permutation_trans.
apply Permutation_sym.
exact: Permutation_middle.
Qed.

Lemma project_churn_bfs_enqueue_fail_eq : forall (T5 : T) (j : i),
  project_churn_bfs (enqueue_fail T5 j) = enqueue_fail (project_churn_bfs T5) j.
Proof.
elim => [|t5 T5 IH] i5 //=.
rewrite /project_churn_bfs_node /ident_adjacentb mem_queue_filter_P //.
case: ifP => _ /=.
  set s := mk_nd_churn _ _ _.
  by rewrite IH.
set v := mk_nd_churn _ _ _.
by rewrite IH.
Qed.

Lemma in_project_churn_bfs_ex_node : forall (T5 : T) (s5 : s), In s5 (project_churn_bfs T5) ->
  exists t5, In t5 T5 /\ project_churn_bfs_node t5 = s5.
Proof.
elim => [|t5 T5 IH] s5 H_in //.
case: H_in => H_in.
  by exists t5; split; first by left.
rewrite -/(In _ _) -/(project_churn_bfs _) in H_in.
apply IH in H_in as [t' [H_in H_eq]].
by exists t'; split; first by right.
Qed.

Lemma fresh_fresh_project_churn_bfs : forall (T5 : T) (i5 : i),
  fresh i5 T5 ->
  fresh i5 (project_churn_bfs T5).
Proof.
elim => [|t5 T5 IH] i5 H_fresh //=.
rewrite /project_churn_bfs_node.
set s := mk_nd_churn _ _ _.
move => s5 H_in.
case: H_in => H_in.
  rewrite -H_in /s /=.
  have H_in': In t5 (t5 :: T5) by left.
  have [H_neq H_fail] := H_fresh _ H_in'.
  split => //.
  move => H_in_q.
  apply H_fail.
  move: H_in_q.
  exact: filter_P_in_after_in_before.
rewrite -/(In _ _) in H_in.
apply IH => //.
move => s' H_in'.
by apply H_fresh; right.
Qed.

Lemma init_queue_churn_init_queue_bfs_eq : forall (T5 : T),
  remove_except_new_fail (init_queue T5) = init_queue (project_churn_bfs T5).
Proof. by elim => [|t5 T5 IH] //=; rewrite IH. Qed.

Lemma project_churn_bfs_enqueue_new_eq : forall (T5 : T) (j : i),
  project_churn_bfs (enqueue_new T5 j) = enqueue_new (project_churn_bfs T5) j.
Proof. by elim => [|t5 T5 IH] j //=; rewrite IH. Qed.

Lemma project_churn_bfs_enqueue_status_eq : forall (T5 : T) (I5 : I) (i5 : i) (lvo5 : lvo),
 project_churn_bfs (enqueue_status T5 I5 i5 lvo5) = project_churn_bfs T5.
Proof.
elim => [|t5 T5 IH] j //=.
case: (ISet.mem _ _) => i5 lvo5 /=; last by rewrite IH.
by rewrite /project_churn_bfs_node /= IH.
Qed.

Lemma project_churn_bfs_ok : forall (T5 : T), bfs_net_ok T5 ->
 churn_net_ok (project_churn_bfs T5).
Proof.
move => T5 H_ok.
elim H_ok; subst; first by apply churn_ok_empty.
move {T5 H_ok}.
move => T' T5 H_ext_ok H_ok H_st_red.
inversion H_st_red; subst.
have H_ext_ok' := bfs_net_ok_permutation _ _ H_ext_ok H.
have H_ok': churn_net_ok (project_churn_bfs T'1).
  apply project_churn_bfs_permutation in H.
  move: H.
  exact: churn_net_ok_permutation.
suff H_suff: churn_net_ok (project_churn_bfs T'2).
  apply project_churn_bfs_permutation in H1.
  move: H1.
  exact: churn_net_ok_permutation.
move: H_ext_ok' H_ok' H0 {T' T5 H_ext_ok H_ok H_st_red H H1} => H_ext_ok H_ok H_red.
inversion H_red; subst; move {H_red}.
- (* init *)
  rewrite /= /project_churn_bfs_node /= init_queue_churn_init_queue_bfs_eq.
  set s_after := mk_nd_churn _ _ _.
  apply churn_ok_red with (Sst5 := project_churn_bfs (T5 ++ T')) => //.
  apply (churn_netst_struct _ _ (project_churn_bfs (T5 ++ T')) (s_after :: project_churn_bfs (T5 ++ enqueue_new T' i5))); try exact: Permutation_refl.
  rewrite 2!project_churn_bfs_distr project_churn_bfs_enqueue_new_eq.
  apply: churn_net_init.
  move {H_ext_ok H_ok s_after}.
  move => s5 H_in.
  apply fresh_fresh_project_churn_bfs in H.
  rewrite project_churn_bfs_distr in H.
  exact: H.
- (* fail *)
  move: H_ext_ok H_ok.
  set t_before := _ _ _ _ _.
  move => H_ext_ok H_ok.
  apply churn_ok_red with (Sst5 := project_churn_bfs (t_before :: T5)) => //.
  apply (churn_netst_struct _ _ (project_churn_bfs (t_before :: T5)) (project_churn_bfs (enqueue_fail T5 i5))); try exact: Permutation_refl.
  rewrite project_churn_bfs_enqueue_fail_eq.
  exact: churn_net_fail.
- (* new *)
  move: H_ext_ok H_ok.
  rewrite /= /project_churn_bfs_node /=.
  set t_before := _ _ _ _ _.
  set s_before := mk_nd_churn _ _ _.
  set s_after := mk_nd_churn _ _ _.
  move => H_ext_ok H_ok.
  apply first_firstin in H.
  apply dequeue_dequeued in H0.
  apply churn_ok_red with (Sst5 := (s_before :: nil) ++ project_churn_bfs T5) => //.
  apply (churn_netst_struct _ _ ((s_before :: nil) ++ project_churn_bfs T5) ((s_after :: nil) ++ project_churn_bfs T5)); try exact: Permutation_refl.
  apply: churn_net_partial.
  apply: churn_partial_new => //.
    apply first_firstin.
    exact: filter_P_first.
  apply dequeue_dequeued.
  move: H0 H.
  exact: dequeued_filter_P.
- (* new *)
  move: H_ext_ok H_ok.
  rewrite /= /project_churn_bfs_node /=.
  set t_before := _ _ _ _ _.
  set s_before := mk_nd_churn _ _ _.
  set s_after := mk_nd_churn _ _ _.
  move => H_ext_ok H_ok.
  apply first_firstin in H.
  apply dequeue_dequeued in H0.
  apply churn_ok_red with (Sst5 := (s_before :: nil) ++ project_churn_bfs T5) => //.
  apply (churn_netst_struct _ _ ((s_before :: nil) ++ project_churn_bfs T5) ((s_after :: nil) ++ project_churn_bfs T5)); try exact: Permutation_refl.
  apply: churn_net_partial.
  apply: churn_partial_new => //.
    apply first_firstin.
    exact: filter_P_first.
  apply dequeue_dequeued.
  move: H0 H.
  exact: dequeued_filter_P.  
- (* broadcast *)
  move: H_ext_ok H_ok.
  rewrite /= /project_churn_bfs_node /=.
  set t_before := _ _ _ _ _.
  by rewrite project_churn_bfs_enqueue_status_eq.
- (* partial *)
  inversion H; subst; move {H}.
  * (* new *)
    move: H_ext_ok H_ok.
    rewrite /= /project_churn_bfs_node /=.
    set t0_before := _ _ _ _ _.
    set t1_before := _ _ _ _ _.
    set s0_before := mk_nd_churn _ _ _.
    set s1 := mk_nd_churn _ _ _.
    set s0_after := mk_nd_churn _ _ _.
    move => H_ext_ok H_ok.
    apply first_firstin in H0.
    apply dequeue_dequeued in H1.
    apply churn_ok_red with (Sst5 := (s0_before :: s1 :: nil) ++ project_churn_bfs T') => //.
    apply (churn_netst_struct _ _ ((s0_before :: nil) ++ s1 :: project_churn_bfs T') ((s0_after :: nil) ++ s1 :: project_churn_bfs T')); try exact: Permutation_refl.
    apply: churn_net_partial.
    apply: churn_partial_new => //.
      apply first_firstin.
      exact: filter_P_first.
    apply dequeue_dequeued.
    move: H1 H0.
    exact: dequeued_filter_P.
  * (* new *)
    move: H_ext_ok H_ok.
    rewrite /= /project_churn_bfs_node /=.
    set t0_before := _ _ _ _ _.
    set t1_before := _ _ _ _ _.
    set s0_before := mk_nd_churn _ _ _.
    set s1 := mk_nd_churn _ _ _.
    set s0_after := mk_nd_churn _ _ _.
    move => H_ext_ok H_ok.
    apply first_firstin in H0.
    apply dequeue_dequeued in H1.
    apply churn_ok_red with (Sst5 := (s0_before :: s1 :: nil) ++ project_churn_bfs T') => //.
    apply (churn_netst_struct _ _ ((s0_before :: nil) ++ s1 :: project_churn_bfs T') ((s0_after :: nil) ++ s1 :: project_churn_bfs T')); try exact: Permutation_refl.
    apply: churn_net_partial.
    apply: churn_partial_new => //.
      apply first_firstin.
      exact: filter_P_first.
    apply dequeue_dequeued.
    move: H1 H0.
    exact: dequeued_filter_P.
  * (* new *)
    move: H_ext_ok H_ok.
    rewrite /= /project_churn_bfs_node /=.
    set t_before := _ _ _ _ _.
    set s_before := mk_nd_churn _ _ _.
    set s_after := mk_nd_churn _ _ _.
    move => H_ext_ok H_ok.
    apply first_firstin in H0.
    apply dequeue_dequeued in H1.
    apply churn_ok_red with (Sst5 := (s_before :: nil) ++ project_churn_bfs T') => //.
    apply (churn_netst_struct _ _ ((s_before :: nil) ++ project_churn_bfs T') ((s_after :: nil) ++ project_churn_bfs T')); try exact: Permutation_refl.
    apply: churn_net_partial.
    apply: churn_partial_new => //.
      apply first_firstin.
      exact: filter_P_first.
    apply dequeue_dequeued.
    move: H1 H0.
    exact: dequeued_filter_P.
  * (* fail *)
    move: H_ext_ok H_ok.
    rewrite /= /project_churn_bfs_node /=.
    set t_before := _ _ _ _ _.
    set s_before := mk_nd_churn _ _ _.
    set s_after := mk_nd_churn _ _ _.
    move => H_ext_ok H_ok.
    apply first_firstin in H0.
    apply dequeue_dequeued in H1.
    apply churn_ok_red with (Sst5 := (s_before :: nil) ++ project_churn_bfs T') => //.
    apply: (churn_netst_struct _ _ ((s_before :: nil) ++ project_churn_bfs T') ((s_after :: nil) ++ project_churn_bfs T')); try exact: Permutation_refl.
    apply: churn_net_partial.
    apply: churn_partial_fail => //.
      apply first_firstin.
      exact: filter_P_first.
    apply dequeue_dequeued.
    move: H1 H0.
    exact: dequeued_filter_P.
  * (* fail *)
    move: H_ext_ok H_ok.
    rewrite /= /project_churn_bfs_node /=.
    set t_before := _ _ _ _ _.
    set s_before := mk_nd_churn _ _ _.
    set s_after := mk_nd_churn _ _ _.
    move => H_ext_ok H_ok.
    apply first_firstin in H0.
    apply dequeue_dequeued in H1.
    apply churn_ok_red with (Sst5 := (s_before :: nil) ++ project_churn_bfs T') => //.
    apply (churn_netst_struct _ _ ((s_before :: nil) ++ project_churn_bfs T') ((s_after :: nil) ++ project_churn_bfs T')); try exact: Permutation_refl.
    apply: churn_net_partial.
    apply: churn_partial_fail => //.
      apply first_firstin.
      exact: filter_P_first.
    apply dequeue_dequeued.
    move: H1 H0.
    exact: dequeued_filter_P.
  * (* fail *)
    move: H_ext_ok H_ok.
    rewrite /= /project_churn_bfs_node /=.
    set t_before := _ _ _ _ _.
    set s_before := mk_nd_churn _ _ _.
    set s_after := mk_nd_churn _ _ _.
    move => H_ext_ok H_ok.
    apply first_firstin in H0.
    apply dequeue_dequeued in H1.
    apply churn_ok_red with (Sst5 := (s_before :: nil) ++ project_churn_bfs T') => //.
    apply (churn_netst_struct _ _ ((s_before :: nil) ++ project_churn_bfs T') ((s_after :: nil) ++ project_churn_bfs T')); try exact: Permutation_refl.
    apply: churn_net_partial.
    apply: churn_partial_fail => //.
      apply first_firstin.
      exact: filter_P_first.
    apply dequeue_dequeued.
    move: H1 H0.
    exact: dequeued_filter_P.
  * (* status *)
    move: H_ext_ok H_ok.
    rewrite /= /project_churn_bfs_node /=.
    apply first_firstin in H0.
    apply dequeue_dequeued in H1.
    set t_before := _ _ _ _ _.
    rewrite /remove_except_new_fail.
    by rewrite (filter_P_firstin_dequeue_eq _ _ _ _ _ _ H0 H1).
  * (* status *)
    move: H_ext_ok H_ok.
    rewrite /= /project_churn_bfs_node /=.
    apply first_firstin in H0.
    apply dequeue_dequeued in H1.
    set t_before := _ _ _ _ _.
    rewrite /remove_except_new_fail.
    by rewrite (filter_P_firstin_dequeue_eq _ _ _ _ _ _ H0 H1).
  * (* status *)
    move: H_ext_ok H_ok.
    rewrite /= /project_churn_bfs_node /=.
    apply first_firstin in H0.
    apply dequeue_dequeued in H1.
    set t_before := _ _ _ _ _.
    rewrite /remove_except_new_fail.
    by rewrite (filter_P_firstin_dequeue_eq _ _ _ _ _ _ H0 H1).
  * (* status *)
    move: H_ext_ok H_ok.
    rewrite /= /project_churn_bfs_node /=.
    apply first_firstin in H0.
    apply dequeue_dequeued in H1.
    set t_before := _ _ _ _ _.
    rewrite /remove_except_new_fail.
    by rewrite (filter_P_firstin_dequeue_eq _ _ _ _ _ _ H0 H1).
  * (* status *)
    move: H_ext_ok H_ok.
    rewrite /= /project_churn_bfs_node /=.
    apply first_firstin in H0.
    apply dequeue_dequeued in H1.
    set t_before := _ _ _ _ _.
    rewrite /remove_except_new_fail.
    by rewrite (filter_P_firstin_dequeue_eq _ _ _ _ _ _ H0 H1).
Qed.

Lemma not_adjacent_self_bfs : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  ~ ISet.In (bfs_ident t5) (bfs_adj t5).
Proof.
move => T5 H_ok.
apply project_churn_bfs_ok in H_ok.
case => i5 q5 I5 b5 L5 /=.
set t5 := mk_nd_bfs _ _ _ _ _.
move => H_in H_ins.
set s5 := mk_nd_churn i5 (remove_except_new_fail q5) I5.
have H_in': In s5 (project_churn_bfs T5).
  have [T' [T6 H_eq]] := in_split t5 T5 H_in.
  rewrite H_eq.
  rewrite project_churn_bfs_distr.
  apply in_or_app.
  by right; left.
have H_ex := not_adjacent_self_churn (project_churn_bfs _) H_ok _ H_in'.
by case: H_ex.
Qed.

Lemma not_self_in_queue_bfs : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  ~ In_queue (msg_new (bfs_ident t5)) (bfs_mbox t5).
Proof.
move => T5 H_ok.
apply project_churn_bfs_ok in H_ok.
case => i5 q5 I5 b5 L5 /=.
set t5 := mk_nd_bfs _ _ _ _ _.
move => H_in H_in_q.
set s5 := mk_nd_churn i5 (remove_except_new_fail q5) I5.
have H_in': In s5 (project_churn_bfs T5).
  have [T' [T6 H_eq]] := in_split t5 T5 H_in.
  rewrite H_eq.
  rewrite project_churn_bfs_distr.
  apply in_or_app.
  by right; left.
have H_ex := not_self_in_queue_churn (project_churn_bfs _) H_ok _ H_in'.
case: H_ex.
exact: filter_P_in_queue.
Qed.

Lemma in_queue_not_in_adj_bfs : forall (T5 : T), bfs_net_ok T5 -> 
  forall (t5 : t), In t5 T5 -> 
  forall (j : i), In_queue (msg_new j) (bfs_mbox t5) -> 
  ~ ISet.In j (bfs_adj t5).
Proof.
move => T5 H_ok.
apply project_churn_bfs_ok in H_ok.
case => i5 q5 I5 b5 L5 /=.
set t5 := mk_nd_bfs _ _ _ _ _.
move => H_in j H_ins.
set s5 := mk_nd_churn i5 (remove_except_new_fail q5) I5.
have H_in': In s5 (project_churn_bfs T5).
  have [T' [T6 H_eq]] := in_split t5 T5 H_in.
  rewrite H_eq.
  rewrite project_churn_bfs_distr.
  apply in_or_app.
  by right; left.
have H_ex := in_queue_not_in_adj_churn (project_churn_bfs _) H_ok s5 H_in'.
apply: H_ex.
exact: filter_P_in_queue.
Qed.

Lemma bfs_net_ok_queue_new_not_in_adj : forall (T5 : T), bfs_net_ok T5 -> 
  forall (t5 : t), In t5 T5 -> 
  forall (j : i), first (bfs_mbox t5) = Some (msg_new j) -> 
  ~ ISet.In j (bfs_adj t5).
Proof.
move => T5 H_ok t5 H_in j H_fst.
apply: (in_queue_not_in_adj_bfs T5) => //.
by auto with queue_in.
Qed.

Lemma level_spec_none : forall (I5 : I) (L5 : L),
  level I5 L5 = None ->
  ~ exists j, exists lv5, level_in I5 L5 j lv5.
Proof.
move => I5 L5.
rewrite /level.
case (lev _) => //.
by case => /= lv' H_lv H_eq.
Qed.

Lemma level_spec_some : forall (I5 : I) (L5 : L) (lv5 : lv),
  level I5 L5 = Some lv5 ->
  exists j, exists lv', min_level I5 L5 j lv' /\ lv5 = lv' + 1%nat.
Proof.
move => I5 L5 lv5.
rewrite /level.
case (lev _) => //.
case => /= lv' H_ex H_eq.
injection H_eq => H_eq'.
by rewrite -H_eq'.
Qed.

Lemma level_add_bot_eq : forall (I5 : I) (L5 : L) (j : i),
  IMap.find j L5 = None ->
  level I5 L5 = level (ISet.add j I5) L5.
Proof.
move => I5 L5 j H_find.
case H_eq: (level _ _) => [lv5|].
  apply level_spec_some in H_eq as [i5 [lv6 [H_min H_eq]]].
  inversion H_min; subst.
  inversion H; subst.
  case H_eq': (level _ _) => [lv7|].
    apply level_spec_some in H_eq' as [i6 [lv8 [H_min' H_eq']]].
    inversion H_min'; subst.
    inversion H3; subst.
    apply ISetFacts.add_3 in H5; last by move => H_eq'; rewrite -H_eq' H_find in H6.
    case (eq_lv lv6 lv8) => H_eq; first by rewrite H_eq.
    contradict H_eq.
    have H_lt_lv6: ~ lv8 < lv6.
      apply (H0 _ i6).
      exact: in_level_in.
    have H_lt_lv8: ~ lv6 < lv8.
      apply (H4 _ i5).
      apply: in_level_in => //.
      exact: ISetFacts.add_2.
    case (lt_eq_lt_dec lv6 lv8) => //.
    by case.
  apply level_spec_none in H_eq'.
  case: H_eq'.
  exists i5; exists lv6.
  apply: in_level_in => //.
  exact: ISetFacts.add_2.
apply level_spec_none in H_eq.
case H_eq': (level _ _) => [lv6|] //.
apply level_spec_some in H_eq' as [i5 [lv7 [H_min H_eq']]].
inversion H_min; subst.
inversion H; subst.
apply ISetFacts.add_3 in H1.
  case: H_eq.   
  exists i5; exists lv7.
  exact: in_level_in.
move => H_eq'.
by rewrite -H_eq' H_find in H2.
Qed.

Section SingleNodeInvBfs.

Variable T5 : T.

Hypothesis H_ok : bfs_net_ok T5.

Variable t5 : t.

Hypothesis H_in : In t5 T5.

Variable P : t -> Prop.

Hypothesis new_node : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' (ISet.add j I5) b5 L5 in
  first q5 = Some (msg_new j) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = None ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  P t_before ->
  P t_after.

Hypothesis fail_eq_node : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' (ISet.remove j I5) b5 (IMap.remove j L5) in
  first q5 = Some (msg_fail j) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = level (ISet.remove j I5) (IMap.remove j L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  P t_before ->
  P t_after.

Hypothesis fail_neq_node : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' (ISet.remove j I5) true (IMap.remove j L5) in
  first q5 = Some (msg_fail j) -> 
  dequeue q5 = Some q' ->
  level I5 L5 <> level (ISet.remove j I5) (IMap.remove j L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  P t_before ->
  P t_after.

Hypothesis fail_root_node : forall (T5 : T) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i),
  let t_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs 0 q' (ISet.remove j I5) b5 L5 in
  first q5 = Some (msg_fail j) -> 
  dequeue q5 = Some q' ->
  bfs_net_ok (t_before :: T5) ->
  P t_before ->
  P t_after.

Hypothesis status_eq_node : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (lv5 : lv),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' I5 b5 (IMap.add j lv5 L5) in
  first q5 = Some (msg_status j (Some lv5)) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = level I5 (IMap.add j lv5 L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  P t_before ->
  P t_after.

Hypothesis status_eq_bot_node : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' I5 b5 (IMap.remove j L5) in
  first q5 = Some (msg_status j None) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = level I5 (IMap.remove j L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  P t_before ->
  P t_after.

Hypothesis status_neq_node : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (lv5 : lv),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' I5 true (IMap.add j lv5 L5) in
  first q5 = Some (msg_status j (Some lv5)) -> 
  dequeue q5 = Some q' ->
  level I5 L5 <> level I5 (IMap.add j lv5 L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  P t_before ->
  P t_after.

Hypothesis status_neq_bot_node : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' I5 true (IMap.remove j L5) in
  first q5 = Some (msg_status j None) -> 
  dequeue q5 = Some q' ->
  level I5 L5 <> level I5 (IMap.remove j L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  P t_before ->
  P t_after.

Hypothesis status_root_node : forall (T5 : T) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (lvo5 : lvo),
  let t_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs 0 q' I5 b5 L5 in
  first q5 = Some (msg_status j lvo5) -> 
  dequeue q5 = Some q' ->
  bfs_net_ok (t_before :: T5) ->
  P t_before ->
  P t_after.

Hypothesis init_eq : forall (T5 T' : T) (i5 : i),
  let t_after := mk_nd_bfs i5 (init_queue T') ISet.empty false (IMap.empty lv) in
  bfs_net_ok (T5 ++ T') ->
  fresh i5 (T5 ++ T') ->
  P t_after.

Hypothesis init_in : forall (T5 T' : T) (i5 : i) (t5 : t) (q' : q),
  let t5_before := mk_nd_bfs (bfs_ident t5) q' (bfs_adj t5) (bfs_broadcast t5) (bfs_levels t5) in
  bfs_net_ok (T5 ++ T') ->
  fresh i5 (T5 ++ T') ->
  bfs_mbox t5 = queue_enqueue q' (msg_new i5) ->
  In t5_before T' ->
  P t5_before ->
  P t5.

Hypothesis fail_in : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (t5 : t) (q' : q),
  let t' := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t5_before := mk_nd_bfs (bfs_ident t5) q' (bfs_adj t5) (bfs_broadcast t5) (bfs_levels t5) in
  bfs_net_ok (t' :: T5) ->
  bfs_mbox t5 = queue_enqueue q' (msg_fail i5) ->
  In t5_before T5 ->
  ISet.In i5 (bfs_adj t5) \/ In_queue (msg_new i5) q' ->
  P t5_before ->
  P t5.

Hypothesis new_fst : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q) (lv5 : lv),
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q'' ->
  level I5 L5 = Some lv5 ->
  i5 <> 0 ->
  let t0_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t1_before := mk_nd_bfs j q' I' b' L' in
  let t0_after := mk_nd_bfs i5 q'' (ISet.add j I5) b5 L5 in
  let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status i5 (Some lv5))) I' b' L' in
  bfs_net_ok (t0_before :: t1_before :: T5) ->
  P t0_before ->
  P t0_after.

Hypothesis new_snd : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q) (lv5 : lv),
  let t0_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t1_before := mk_nd_bfs j q' I' b' L' in
  let t0_after := mk_nd_bfs i5 q'' (ISet.add j I5) b5 L5 in
  let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status i5 (Some lv5))) I' b' L' in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q'' ->
  level I5 L5 = Some lv5 ->
  i5 <> 0 ->
  bfs_net_ok (t0_before :: t1_before :: T5) ->
  P t1_before ->
  P t1_after.

Hypothesis new_not_exists : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' (ISet.add j I5) b5 L5 in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q' -> 
  i5 <> 0 ->
  ~ (exists t5 : t, In t5 T5 /\ bfs_ident t5 = j) ->
  bfs_net_ok (t_before :: T5) ->
  P t_before ->
  P t_after.

Hypothesis new_root_fst : forall (T5 : T) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q),
 first q5 = Some (msg_new j) ->
 dequeue q5 = Some q'' ->
 let t0_before := mk_nd_bfs 0 q5 I5 b5 L5 in
 let t1_before := mk_nd_bfs j q' I' b' L' in
 let t0_after := mk_nd_bfs 0 q'' (ISet.add j I5) b5 L5 in
 let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status 0 (Some 0))) I' b' L' in
 bfs_net_ok (t0_before :: t1_before :: T5) ->
 P t0_before ->
 P t0_after.

Hypothesis new_root_snd : forall (T5 : T) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q),
 first q5 = Some (msg_new j) ->
 dequeue q5 = Some q'' ->
 let t0_before := mk_nd_bfs 0 q5 I5 b5 L5 in
 let t1_before := mk_nd_bfs j q' I' b' L' in
 let t0_after := mk_nd_bfs 0 q'' (ISet.add j I5) b5 L5 in
 let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status 0 (Some 0))) I' b' L' in
 bfs_net_ok (t0_before :: t1_before :: T5) ->
 P t1_before ->
 P t1_after.

Hypothesis new_root_not_exists : forall (T5 : T) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q),
  let t_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs 0 q' (ISet.add j I5) b5 L5 in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q' -> 
  ~ (exists t5 : t, In t5 T5 /\ bfs_ident t5 = j) ->
  bfs_net_ok (t_before :: T5) ->
  P t_before ->
  P t_after.

Hypothesis broadcast_fst : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (L5 : L),
  let t_before := mk_nd_bfs i5 q5 I5 true L5 in
  let t_after := mk_nd_bfs i5 q5 I5 false L5 in
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  P t_before ->
  P t_after.

Hypothesis broadcast_snd : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (L5 : L) (t5 : t) (q' : q),
  let t_before := mk_nd_bfs i5 q5 I5 true L5 in
  let t_after := mk_nd_bfs i5 q5 I5 false L5 in
  let t5_before := mk_nd_bfs (bfs_ident t5) q' (bfs_adj t5) (bfs_broadcast t5) (bfs_levels t5) in
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  bfs_mbox t5 = queue_enqueue q' (msg_status i5 (level I5 L5)) ->
  In t5_before T5 ->
  ISet.In (bfs_ident t5) I5 ->
  P t5_before ->
  P t5.

Theorem P_inv_bfs : P t5.
Proof.
move: T5 H_ok t5 H_in.
clear T5 H_ok t5 H_in.
move => T5.
elim => //.
move => T' T0 H_ok IH H_st_red.
inversion H_st_red; subst.
have H_ok' := bfs_net_ok_permutation _ _ H_ok H.
have IH': forall t5 : t, In t5 T'1 -> P t5.
  move => t5 H_in.
  apply IH.
  apply Permutation_sym in H.
  exact: (Permutation_in _ H).
suff H_suff: forall t5 : t, In t5 T'2 -> P t5.
  move => t5 H_in.
  apply H_suff.
  apply Permutation_sym in H1.
  exact: (Permutation_in _ H1).
clear IH H_st_red H H1 H_ok.
move: H_ok' H0 IH' => H_ok H_red IH.
inversion H_red; subst.
- (* init *)
  move: H_ok IH H H_red.
  clear H_ok.
  set t_after := mk_nd_bfs _ _ _ _ _.
  rewrite /=.
  move => H_ok IH H H_red t5 H_in.
  case H_in; clear H_in; move => H_in; first by rewrite -H_in; exact: (init_eq T1).
  apply in_app_or in H_in.
  case H_in; clear H_in; move => H_in; first by apply IH; apply in_or_app; left.
  apply in_enqueue_new in H_in as [q' [H_eq H_in]].
  move: H_in.
  clear H_in.
  set t5_before := mk_nd_bfs (bfs_ident t5) q' (bfs_adj t5) (bfs_broadcast t5) (bfs_levels t5).
  move => H_in.
  have H_in_t5: In t5_before (T1 ++ T'0) by apply in_or_app; right.
  have H_p := IH _ H_in_t5.
  exact: (init_in T1 T'0 i5 _ q').
- (* fail *)
  move: H_ok IH H_red.
  clear H_ok.
  set t' := mk_nd_bfs _ _ _ _ _.
  rewrite /=.
  move => H_ok IH H_red t5 H_in.
  case (in_enqueue_fail T1 t5 i5 H_in) => H_or; last by apply IH; right.
  move: H_or => [q' [H_eq [H_in' H_or']]].
  move: H_in'.
  rewrite /put_mbox /= /t_put_mbox /=.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_in'.
  have H_or: t' = t5_before \/ In t5_before T1 by right.
  have H_p := IH t5_before H_or.
  exact: (fail_in T1 i5 q5 I5 b5 L5 _ q').
- (* new_not_exists *)
  move: H_ok IH H_red.
  clear H_ok.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  rewrite /=.
  move => H_ok IH H_red t5 H_in.
  case H_in; clear H_in; move => H_in; last by apply IH; right.
  rewrite -H_in.
  by apply: (new_not_exists T1 _ q5); last by apply IH; left.
- (* new_root_not_exists *)
  move: H_ok IH H_red.
  clear H_ok.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  rewrite /=.
  move => H_ok IH H_red t5 H_in.
  case H_in; clear H_in; move => H_in; last by apply IH; right.
  rewrite -H_in.
  by apply: (new_root_not_exists T1 q5); last by apply IH; left.
- (* timeout *)
  move: H_ok IH H_red.
  clear H_ok.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  rewrite /=.
  move => H_ok IH H_red t5 H_in.
  case H_in; clear H_in; move => H_in.
    by rewrite -H_in; apply: (broadcast_fst T1 _ q5); last by apply IH; first by left.
  apply in_enqueue_status in H_in as [H_q|[H_in H_ins]]; last by apply IH; right.
  move: H_q => [[q6 [H_eq H_in]] H_ins].
  move: H_in.
  clear H_in.
  rewrite /put_mbox /= /t_put_mbox /=.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_in.
  have H_in_t5: t_before = t5_before \/ In t5_before T1 by right.
  have H_p := IH _ H_in_t5.
  exact: (broadcast_snd T1 i5 q5 I5 L5 _ q6).
- (* node *)
  inversion H; subst.
  * (* new *)
    move: H_ok IH H_red.
    clear H_ok.
    set t0_before := mk_nd_bfs _ _ _ _ _.
    set t1_before := mk_nd_bfs _ _ _ _ _.
    set t0_after := mk_nd_bfs _ _ _ _ _.
    set t1_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H_red t5 H_in.
    case H_in; clear H_in; move => H_in.
      rewrite -H_in.
      by apply: (new_fst T'0 i5 _ _ _ _ _ q' I' b' L' _ lv5 H0) => //; last by apply IH; left.
    case H_in; clear H_in; move => H_in; last by apply IH; right; right.
    rewrite -H_in.
    by apply (new_snd T'0 _ q5 I5 b5 L5 _ _ _ _ _ q'') => //; last by apply IH; right; left.
  * (* new_root *)
    move: H_ok IH H_red.
    clear H_ok.
    set t0_before := mk_nd_bfs _ _ _ _ _.
    set t1_before := mk_nd_bfs _ _ _ _ _.
    set t0_after := mk_nd_bfs _ _ _ _ _.
    set t1_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H_red t5 H_in.
    case H_in; clear H_in; move => H_in.
      rewrite -H_in.
      by apply: (new_root_fst T'0 _ _ _ _ _ q' I' b' L' _ H0) => //; last by apply IH; left.
    case H_in; clear H_in; move => H_in; last by apply IH; right; right.
    rewrite -H_in.
    by apply (new_root_snd T'0 q5 I5 b5 L5 _ _ _ _ _ q'') => //; last by apply IH; right; left.  
  * (* new *)
    move: H_ok IH H H_red.
    clear H_ok.
    set t_before := mk_nd_bfs _ _ _ _ _.
    set t_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red t5 H_in.
    case H_in; clear H_in; move => H_in; last by apply IH; right.
    rewrite -H_in; apply (new_node T'0 _ q5) => //.
    by rewrite -/t_before; apply IH; left.
  (* fail_eq *)
  * move: H_ok IH H H_red.
    clear H_ok.
    set t_before := mk_nd_bfs _ _ _ _ _.
    set t_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red t5 H_in.
    case H_in; clear H_in; move => H_in; last by apply IH; right.
    rewrite -H_in; apply (fail_eq_node T'0 _ q5) => //.
    by rewrite -/t_before; apply IH; left.
  (* fail_neq *)
  * move: H_ok IH H H_red.
    clear H_ok.
    set t_before := mk_nd_bfs _ _ _ _ _.
    set t_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red t5 H_in.
    case H_in; clear H_in; move => H_in; last by apply IH; right.
    rewrite -H_in; apply (fail_neq_node T'0 _ q5 _ b5) => //.
    by rewrite -/t_before; apply IH; left.
  (* fail_root *)
  * move: H_ok IH H H_red.
    clear H_ok.
    set t_before := mk_nd_bfs _ _ _ _ _.
    set t_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red t5 H_in.
    case H_in; clear H_in; move => H_in; last by apply IH; right.
    rewrite -H_in; apply (fail_root_node T'0 q5) => //.
    by rewrite -/t_before; apply IH; left.
  (* status_eq *)
  * move: H_ok IH H H_red.
    clear H_ok.
    set t_before := mk_nd_bfs _ _ _ _ _.
    set t_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red t5 H_in.
    case H_in; clear H_in; move => H_in; last by apply IH; right.
    rewrite -H_in; apply (status_eq_node T'0 _ q5) => //.
    by rewrite -/t_before; apply IH; left.
  (* status_eq_bot *)
  * move: H_ok IH H H_red.
    clear H_ok.
    set t_before := mk_nd_bfs _ _ _ _ _.
    set t_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red t5 H_in.
    case H_in; clear H_in; move => H_in; last by apply IH; right.
    rewrite -H_in; apply (status_eq_bot_node T'0 _ q5) => //.
    by rewrite -/t_before; apply IH; left.
  * (* status_neq *)
    move: H_ok IH H H_red.
    clear H_ok.
    set t_before := mk_nd_bfs _ _ _ _ _.
    set t_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red t5 H_in.
    case H_in; clear H_in; move => H_in; last by apply IH; right.
    rewrite -H_in; apply (status_neq_node T'0 _ q5 _ b5) => //.
    by rewrite -/t_before; apply IH; left.
  (* status_neq_bot *)
  * move: H_ok IH H H_red.
    clear H_ok.
    set t_before := mk_nd_bfs _ _ _ _ _.
    set t_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red t5 H_in.
    case H_in; clear H_in; move => H_in; last by apply IH; right.
    rewrite -H_in; apply (status_neq_bot_node T'0 _ q5 _ b5) => //.
    by rewrite -/t_before; apply IH; left.
  (* status_root *)
  * move: H_ok IH H H_red.
    clear H_ok.
    set t_before := mk_nd_bfs _ _ _ _ _.
    set t_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red t5 H_in.
    case H_in; clear H_in; move => H_in; last by apply IH; right.
    rewrite -H_in; apply (status_root_node T'0 q5 _ _ _ _ j lvo5) => //.
    by rewrite -/t_before; apply IH; left.
Qed.

End SingleNodeInvBfs.

Lemma bfs_net_ok_root_levels_empty : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  bfs_ident t5 = 0 ->
  bfs_levels t5 = IMap.empty lv.
Proof.
move => T5 H_ok t5 H_in.
pose P_curr (t5 : t) := bfs_ident t5 = 0 -> bfs_levels t5 = IMap.empty lv.
rewrite -/(P_curr _).
by apply (P_inv_bfs T5); rewrite /P_curr //.
Qed.

Lemma level_empty_map_none : forall (I5 : I),
  level I5 (IMap.empty lv) = None.
Proof.
move => I5.
case H_eq: (level _ _) => [lv5|] //.
apply level_spec_some in H_eq.
move: H_eq => [j [lv' [H_min H_eq]]].
inversion H_min.
inversion H.
apply IMapFacts.find_mapsto_iff in H2.
by apply IMapFacts.empty_mapsto_iff in H2.
Qed.

Lemma bfs_net_ok_root_levels_bot : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  bfs_ident t5 = 0 ->
  forall (j : i), IMap.find j (bfs_levels t5) = None.
Proof.
move => T5 H_ok t5 H_in H_eq j.
have H_emp := bfs_net_ok_root_levels_empty _ H_ok _ H_in H_eq.
rewrite H_emp.
apply IMapFacts.not_find_in_iff.
move => H_in'.
by apply IMapFacts.empty_in_iff in H_in'.
Qed.

Lemma in_network_no_id_fails_inv_bfs : 
  forall (T5 : T), bfs_net_ok T5 ->
    forall (t5 t' : t), In t5 T5 -> In t' T5 -> 
      ~ In_queue (msg_fail (bfs_ident t5)) (bfs_mbox t').
Proof.
move => T5 H_ok.
apply project_churn_bfs_ok in H_ok.
case => i5 q5 I5 b5 L5 /=.
set t5 := mk_nd_bfs _ _ _ _ _.
case => j q' I' b' L' /=.
set t' := mk_nd_bfs _ _ _ _ _.
move => H_in H_in'.
set s5 := mk_nd_churn i5 (remove_except_new_fail q5) I5.
set s' := mk_nd_churn j (remove_except_new_fail q') I'.
have H_in_s5: In s5 (project_churn_bfs T5).
  have [T' [T6 H_eq]] := in_split t5 T5 H_in.
  rewrite H_eq.
  rewrite project_churn_bfs_distr.
  apply in_or_app.
  by right; left.
have H_in_s': In s' (project_churn_bfs T5).
  have [T7 [T8 H_eq]] := in_split _ _ H_in'.
  rewrite H_eq.
  rewrite project_churn_bfs_distr.
  apply in_or_app.
  by right; left.
move => H_in_q.
have H_ex := in_network_no_id_fails_inv_churn (project_churn_bfs _) H_ok _ _ H_in_s5 H_in_s'.
case: H_ex.
exact: filter_P_in_queue.
Qed.

Lemma in_after_all_fail_status : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  forall (j : i) (lvo5 : lvo), In_queue_after_all (msg_fail j) (msg_status j lvo5) (bfs_mbox t5).
Proof.
move => T5 H_ok t5 H_in.
pose P_curr (t5 : t) := forall (j : i) (lvo5 : lvo), In_queue_after_all (msg_fail j) (msg_status j lvo5) (bfs_mbox t5).
rewrite -/(P_curr _).
apply (P_inv_bfs T5); rewrite /P_curr //= {H_ok T5 H_in t5 P_curr}; eauto with queue_in.
- (* init *)
  move => T5 T' i5 H_ok H_fresh j lvo5 {H_ok H_fresh T5 i5}.
  move: T' j lvo5.
  case => [|t5 T'] j lvo5 //.
  left.
  move: T' j lvo5 {t5}.
  elim => [|t5 T' IH] j lvo5 H_notin //.
  case: H_notin => //.
  exact: IH.
- (* init *)
  move => T5 T' i5 t5 q5 H_ok H_fresh H_eq.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_bef j lvo5.
  rewrite H_eq.
  by right; split.
- (* fail *)
  move => T5 i5 q5 I5 b5 L5 t5 q'.
  set t' := mk_nd_bfs _ _ _ _ _.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_eq H_in H_or H_bef j lvo5.
  rewrite H_eq.
  by right; split.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5.
  case (eq_i i6 i5) => H_eq.
    left; rewrite H_eq.
    have H_in: In t0_before (t0_before :: t1_before :: T5) by left.
    have H_in': In t1_before (t0_before :: t1_before :: T5) by right; left.
    exact: (in_network_no_id_fails_inv_bfs _ H_ok _ _ H_in H_in').
  by right; split; first by move => H_eq'; injection H_eq'.
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5.
  case (eq_i i6 0) => H_eq.
    left; rewrite H_eq.
    have H_in: In t0_before (t0_before :: t1_before :: T5) by left.
    have H_in': In t1_before (t0_before :: t1_before :: T5) by right; left.
    exact: (in_network_no_id_fails_inv_bfs _ H_ok _ _ H_in H_in').
  by right; split; first by move => H_eq'; injection H_eq'.
- (* timeout *)
  move => T5 i5 q5 I5 L5 t5 q' H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_eq H_in H_ins H_bef j lvo5.
  rewrite H_eq /=.
  case (eq_i j i5) => H_eq'.
    left; rewrite H_eq'.
    have H_in': In t_before (t_before :: T5) by left.
    have H_in'': In t5_before (t_before :: T5) by right.
    exact: (in_network_no_id_fails_inv_bfs _ H_ok _ _ H_in' H_in'').
  by right; split; first by move => H_eq''; injection H_eq''.
Qed.

Lemma or_in_then_in_or_queue_bfs : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 t' : t), In t5 T5 -> In t' T5 ->
  ISet.In (bfs_ident t') (bfs_adj t5) \/ In_queue (msg_new (bfs_ident t')) (bfs_mbox t5) ->
  ISet.In (bfs_ident t5) (bfs_adj t') \/ In_queue (msg_new (bfs_ident t5)) (bfs_mbox t').
Proof.
move => T5 H_ok.
apply project_churn_bfs_ok in H_ok.
case => i5 q5 I5 b5 L5 /=.
set t5 := mk_nd_bfs _ _ _ _ _.
case => j q' I' b' L' /=.
set t' := mk_nd_bfs _ _ _ _ _.
move => H_in H_in'.
set s5 := mk_nd_churn i5 (remove_except_new_fail q5) I5.
set s' := mk_nd_churn j (remove_except_new_fail q') I'.
have H_in_s5: In s5 (project_churn_bfs T5).
  have [T' [T6 H_eq]] := in_split t5 T5 H_in.
  rewrite H_eq.
  rewrite project_churn_bfs_distr.
  apply in_or_app.
  by right; left.
have H_in_s': In s' (project_churn_bfs T5).
  have [T7 [T8 H_eq]] := in_split _ _ H_in'.
  rewrite H_eq.
  rewrite project_churn_bfs_distr.
  apply in_or_app.
  by right; left.
move => H_in_q.
have H_in_q': ISet.In j I5 \/ In_queue (msg_new j) (remove_except_new_fail q5).
  case: H_in_q => H_in_q; first by left.
  right.
  exact: filter_P_in_queue.
have H_ex := or_in_then_in_or_queue_churn (project_churn_bfs _) H_ok _ _ H_in_s5 H_in_s' H_in_q'.
case: H_ex => H_ex; first by left.
right.
move: H_ex.
exact: filter_P_in_after_in_before.
Qed.

Lemma in_queue_status_then_new : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  forall (j : i) (lvo5 : lvo), In_queue (msg_status j lvo5) (bfs_mbox t5) ->
  In_queue (msg_new j) (bfs_mbox t5) \/ ISet.In j (bfs_adj t5).
Proof.
move => T5 H_ok t5 H_in.
pose P_curr (t5 : t) := forall (j : i) (lvo5 : lvo), 
  In_queue (msg_status j lvo5) (bfs_mbox t5) ->
  In_queue (msg_new j) (bfs_mbox t5) \/ ISet.In j (bfs_adj t5).
rewrite -/(P_curr _).
apply (P_inv_bfs T5); rewrite /P_curr //= {H_ok T5 H_in t5 P_curr}.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_in_q.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_in_q': In_queue (msg_status i6 lvo5) q5. 
    exact: (dequeued_in_after_in_before _ q').
  case (eq_i i6 j) => H_eq; first by right; apply ISetFacts.add_1.
  suff H_suff: In_queue (msg_new i6) q5 \/ ISet.In i6 I5.
    case: H_suff => H_suff; last by right; apply ISetFacts.add_2.  
    left.
    by apply (dequeued_neq_in_before_in_after q5 _ (msg_new j)); first by injection => H_eq'; rewrite H_eq' in H_eq.
  exact: (H_bef _ lvo5).
- (* fail_node_eq *)
  move => T5 i5 q5 I5 b5 l5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_in_q.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_in_q': In_queue (msg_status i6 lvo5) q5. 
    exact: (dequeued_in_after_in_before _ q').
  case (eq_i j i6) => H_eq.
    rewrite -H_eq in H_in_q, H_in_q'.
    have H_all: In_queue_after_all (msg_fail j) (msg_status j lvo5) q5.
      by apply (in_after_all_fail_status (t_before :: T5) H_ok t_before); last by left.
    contradict H_in_q'.
    by apply firstin_after_all_not_in with (a := (msg_fail j)).
  suff H_suff: In_queue (msg_new i6) q5 \/ ISet.In i6 I5.
    case: H_suff => H_suff; last by right; apply ISetFacts.remove_2; first by contradict H_eq.
    left.
    exact: (dequeued_neq_in_before_in_after q5 _ (msg_fail j)).
   exact: (H_bef _ lvo5).
- (* fail_node *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_in_q.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_in_q': In_queue (msg_status i6 lvo5) q5. 
    exact: (dequeued_in_after_in_before _ q').
  case (eq_i j i6) => H_eq.
    rewrite -H_eq in H_in_q, H_in_q'.
    have H_all: In_queue_after_all (msg_fail j) (msg_status j lvo5) q5.
      by apply (in_after_all_fail_status (t_before :: T5) H_ok t_before); last by left.
    contradict H_in_q'.
    by apply firstin_after_all_not_in with (a := (msg_fail j)).
  suff H_suff: In_queue (msg_new i6) q5 \/ ISet.In i6 I5.
    case: H_suff => H_suff; last by right; apply ISetFacts.remove_2; first by contradict H_eq.
    left.
    exact: (dequeued_neq_in_before_in_after q5 _ (msg_fail j)).
  exact: (H_bef _ lvo5).
- (* fail_node *)
  move => T5 q5 I5 b5 L5 q' j H_fst H_deq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_in_q.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_in_q': In_queue (msg_status i6 lvo5) q5. 
    exact: (dequeued_in_after_in_before _ q').
  case (eq_i j i6) => H_eq.
    rewrite -H_eq in H_in_q, H_in_q'.
    have H_all: In_queue_after_all (msg_fail j) (msg_status j lvo5) q5.
      by apply (in_after_all_fail_status (t_before :: T5) H_ok t_before); last by left.
    contradict H_in_q'.
    by apply firstin_after_all_not_in with (a := (msg_fail j)).
  suff H_suff: In_queue (msg_new i6) q5 \/ ISet.In i6 I5.
    case: H_suff => H_suff; last by right; apply ISetFacts.remove_2; first by contradict H_eq.
    left.
    exact: (dequeued_neq_in_before_in_after q5 _ (msg_fail j)).
  exact: (H_bef _ lvo5).
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_in_q.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_in_q': In_queue (msg_status i6 lvo5) q5. 
    exact: (dequeued_in_after_in_before _ q').
  apply H_bef in H_in_q'.
  case: H_in_q' => H_or; last by right.
  left.
  exact: (dequeued_neq_in_before_in_after q5 _ (msg_status j (Some lv5))).
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_in_q.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_in_q': In_queue (msg_status i6 lvo5) q5. 
    exact: (dequeued_in_after_in_before _ q').
  apply H_bef in H_in_q'.
  case: H_in_q' => H_or; last by right.
  left.
  exact: (dequeued_neq_in_before_in_after q5 _ (msg_status j None)).
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_in_q.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_in_q': In_queue (msg_status i6 lvo5) q5. 
    exact: (dequeued_in_after_in_before _ q').
  apply H_bef in H_in_q'.
  case: H_in_q' => H_or; last by right.
  left.
  exact: (dequeued_neq_in_before_in_after q5 _ (msg_status j (Some lv5))).
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_in_q.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_in_q': In_queue (msg_status i6 lvo5) q5. 
    exact: (dequeued_in_after_in_before _ q').
  apply H_bef in H_in_q'.
  case: H_in_q' => H_or; last by right.
  left.
  exact: (dequeued_neq_in_before_in_after q5 _ (msg_status j None)).
- (* status *)
  move => T5 q5 I5 b5 L5 q' j lvo5 H_fst H_deq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo' H_in_q.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_in_q': In_queue (msg_status i6 lvo') q5. 
    exact: (dequeued_in_after_in_before _ q').
  apply H_bef in H_in_q'.
  case: H_in_q' => H_or; last by right.
  left.
  exact: (dequeued_neq_in_before_in_after q5 _ (msg_status j lvo5)).
- (* init *)
  move => T5 T' i5 H_ok H_fresh j lvo5 H_in_q.
  contradict H_in_q.
  move: T' j lvo5 {T5 i5 H_ok H_fresh}.
  elim => [|t5 T5 IH] j lvo5 //=.
  move => H_in_q.
  case: H_in_q => H_in_q //.
  by contradict H_in_q.
- (* init *)
  move => T5 T' i5 t5 q' H_ok H_fresh H_eq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_bef j lvo5 H_in_q.
  rewrite H_eq /=.
  rewrite H_eq /= in H_in_q.
  case: H_in_q => H_in_q //.
  suff H_suff: In_queue (msg_new j) q' \/ ISet.In j (bfs_adj t5).
    case: H_suff => H_suff; first by left; right.
    by right.
  have H_in': In t_before (T5 ++ T') by apply in_or_app; right.
  move: H_in_q.
  exact: H_bef.
- (* fail *)
  move => T5 i5 q5 I5 b5 L5 t5 q'.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_eq H_in H_or H_bef j lvo5 H_in_q.
  rewrite H_eq /=.
  rewrite H_eq /= in H_in_q.
  case: H_in_q => H_in_q //.
  suff H_suff: In_queue (msg_new j) q' \/ ISet.In j (bfs_adj t5).
    case: H_suff => H_suff; first by left; right.
    by right.
  move: H_in_q.
  exact: H_bef.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_in_q.
  case (eq_i j i6) => H_eq; first by rewrite -H_eq; right; apply ISetFacts.add_1.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_in_q': In_queue (msg_status i6 lvo5) q5. 
    exact: (dequeued_in_after_in_before _ q'').
  apply H_bef in H_in_q'.
  case: H_in_q' => H_or; last by right; apply ISetFacts.add_2.
  left.
  apply (dequeued_neq_in_before_in_after q5 _ (msg_new j)) => //.
  move => H_eq'.
  by injection H_eq'.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_eq.
  case: H_eq => H_eq.
    injection H_eq => H_eq' H_eq''.
    rewrite H_eq''.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    have H_or: ISet.In j I5 \/ In_queue (msg_new j) q5 by right.
    have H_in: In t0_before (t0_before :: t1_before :: T5) by left.
    have H_in': In t1_before (t0_before :: t1_before :: T5) by right; left.
    have H_then := or_in_then_in_or_queue_bfs _ H_ok _ _ H_in H_in' H_or.
    rewrite /= in H_then.
    case: H_then => H_then; first by right.
    by left; right.
  apply H_bef in H_eq.
  case: H_eq => H_eq; first by left; right.
  by right.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' H_fst H_deq H_neq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_in_q.
  case (eq_i j i6) => H_eq; first by rewrite -H_eq; right; apply ISetFacts.add_1.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_in_q': In_queue (msg_status i6 lvo5) q5. 
    exact: (dequeued_in_after_in_before _ q').
  apply H_bef in H_in_q'.
  case: H_in_q' => H_or; last by right; apply ISetFacts.add_2.
  left.
  apply (dequeued_neq_in_before_in_after q5 _ (msg_new j)) => //.
  move => H_eq'.
  by injection H_eq'.
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_in_q.
  case (eq_i j i6) => H_eq; first by rewrite -H_eq; right; apply ISetFacts.add_1.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_in_q': In_queue (msg_status i6 lvo5) q5. 
    exact: (dequeued_in_after_in_before _ q'').
  apply H_bef in H_in_q'.
  case: H_in_q' => H_or; last by right; apply ISetFacts.add_2.
  left.
  apply (dequeued_neq_in_before_in_after q5 _ (msg_new j)) => //.
  move => H_eq'.
  by injection H_eq'.
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_eq.
  case: H_eq => H_eq.
    injection H_eq => H_eq' H_eq''.
    rewrite H_eq''.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    have H_or: ISet.In j I5 \/ In_queue (msg_new j) q5 by right.
    have H_in: In t0_before (t0_before :: t1_before :: T5) by left.
    have H_in': In t1_before (t0_before :: t1_before :: T5) by right; left.
    have H_then := or_in_then_in_or_queue_bfs _ H_ok _ _ H_in H_in' H_or.
    rewrite /= in H_then.
    case: H_then => H_then; first by right.
    by left; right.
  apply H_bef in H_eq.
  case: H_eq => H_eq; first by left; right.
  by right.
- (* new *)
  move => T5 q5 I5 b5 L5 j q' H_fst H_deq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_in_q.
  case (eq_i j i6) => H_eq; first by rewrite -H_eq; right; apply ISetFacts.add_1.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_in_q': In_queue (msg_status i6 lvo5) q5. 
    exact: (dequeued_in_after_in_before _ q').
  apply H_bef in H_in_q'.
  case: H_in_q' => H_or; last by right; apply ISetFacts.add_2.
  left.
  apply (dequeued_neq_in_before_in_after q5 _ (msg_new j)) => //.
  move => H_eq'.
  by injection H_eq'.
- (* timeout *)
  move => T5 i5 q5 I5 L5 t5 q' H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_q H_in H_ins H_bef j lvo5 H_eq.
  rewrite H_q /= in H_eq, H_ins.
  rewrite H_q /=.
  case: H_eq => H_eq.
    injection H_eq => H_eq' H_eq''.
    rewrite H_eq''.
    have H_or: ISet.In (bfs_ident t5) I5 \/ In_queue (msg_new (bfs_ident t5)) q5 by left.
    have H_in': In t_before (t_before :: T5) by left.
    have H_in'': In t5_before (t_before :: T5) by right.
    have H_then := or_in_then_in_or_queue_bfs _ H_ok _ _ H_in' H_in'' H_or.
    rewrite /= in H_then.
    case: H_then => H_then; first by right.
    by left; right.
  suff H_suff: In_queue (msg_new j) q' \/ ISet.In j (bfs_adj t5).
    case: H_suff => H_suff; first by left; right.
    by right.
  by apply H_bef in H_eq.
Qed.

Lemma new_in_mbox_in_or_fail_bfs : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  forall (j : i), In_queue (msg_new j) (bfs_mbox t5) -> 
  (forall (t' : t), In t' T5 -> bfs_ident t' <> j) ->
  In_queue (msg_fail j) (bfs_mbox t5).
Proof.
move => T5 H_ok.
apply project_churn_bfs_ok in H_ok.
case => i5 q5 I5 b5 L5 /=.
set t5 := mk_nd_bfs _ _ _ _ _.
move => H_in j.
set s5 := mk_nd_churn i5 (remove_except_new_fail q5) I5.
have H_ex := new_in_mbox_in_or_fail_churn (project_churn_bfs T5) H_ok s5 _ j.
move => H_new_in_q H_neq.
suff H_suff: In_queue (msg_fail j) (churn_mbox s5).
  move: H_suff.
  exact: filter_P_in_after_in_before.
apply: H_ex. 
- have [T' [T6 H_eq]] := in_split t5 T5 H_in.
  rewrite H_eq.
  rewrite project_churn_bfs_distr.
  apply in_or_app.
  by right; left.
- exact: filter_P_in_queue.
- move => s' H_in'.
  apply in_project_churn_bfs_ex_node in H_in' as [t' [H_in' H_eq]].
  have H_neq' := H_neq _ H_in'.
  by rewrite -H_eq.
Qed.

Lemma fresh_new_not_in_queue_bfs : forall (T5 : T), bfs_net_ok T5 ->
  forall (i5 : i), fresh i5 T5 ->
  forall (t5 : t), In t5 T5 ->
  ~ In_queue (msg_new i5) (bfs_mbox t5).
Proof.
move => T5 H_ok i5 H_fresh t5 H_in H_in_q.
have H_ident_neq : forall t' : t, In t' T5 -> bfs_ident t' <> i5.
  move => t' H_inn H_eq'.
  have [H_neq H_fail] := H_fresh _ H_inn.
  by contradict H_neq.
have H_new_in := new_in_mbox_in_or_fail_bfs _ H_ok _ H_in _ H_in_q H_ident_neq.
by have [H_neq H_fail] := H_fresh _ H_in.
Qed.

Lemma in_adj_exists_or_fail_bfs : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  forall (j : i), ISet.In j (bfs_adj t5) -> 
  ((exists t' : t, In t' T5 /\ bfs_ident t' = j) \/ In_queue (msg_fail j) (bfs_mbox t5)).
Proof.
move => T5 H_ok.
apply project_churn_bfs_ok in H_ok.
case => i5 q5 I5 b5 L5 /=.
set t5 := mk_nd_bfs _ _ _ _ _.
move => H_in j H_ins.
set s5 := mk_nd_churn i5 (remove_except_new_fail q5) I5.
have H_in': In s5 (project_churn_bfs T5).
  have [T' [T6 H_eq]] := in_split t5 T5 H_in.
  rewrite H_eq.
  rewrite project_churn_bfs_distr.
  apply in_or_app.
  by right; left.
have H_ex := in_adj_exists_or_fail_churn (project_churn_bfs _) H_ok s5 H_in' _ H_ins.
case: H_ex => H_ex; first last.
  right.
  move: H_ex.
  exact: filter_P_in_after_in_before.  
left.
move: H_ex => [s' [H_in'' H_eq]].
apply in_project_churn_bfs_ex_node in H_in'' as [t' [H_in_t' H_eq']].
exists t'; split => //.
by rewrite -H_eq' in H_eq.
Qed.

Lemma fresh_not_in_adj_bfs : forall (T5 : T), bfs_net_ok T5 ->
  forall (i5 : i), fresh i5 T5 ->
  forall (t5 : t), In t5 T5 ->
  ~ ISet.In i5 (bfs_adj t5).
Proof.
move => T5 H_ok i5 H_fresh t5 H_in H_ins.
case (in_adj_exists_or_fail_bfs _ H_ok _ H_in _ H_ins) => H_or.
  move: H_or => [t' [H_in' H_eq]].
  have [H_neq H_fail] := H_fresh _ H_in'.
  by contradict H_neq.
by have [H_neq H_fail] := H_fresh _ H_in.
Qed.

Lemma in_after_all_status_new : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  forall (j : i) (lvo5 : lvo), In_queue_after_all (msg_status j lvo5) (msg_new j) (bfs_mbox t5).
Proof.
move => T5 H_ok t5 H_in.
pose P_curr (t5 : t) := forall (j : i) (lvo5 : lvo), 
  In_queue_after_all (msg_status j lvo5) (msg_new j) (bfs_mbox t5).
rewrite -/(P_curr _).
apply (P_inv_bfs T5); rewrite /P_curr //= {H_ok T5 H_in t5 P_curr}; eauto with queue_in.
- (* init *)
  move => T5 T' i5 H_ok H_fresh j lvo5.
  move {T5 i5 H_ok H_fresh}.
  move: T' j lvo5.
  case => [|t5 T5] j lvo5 //.
  left.
  move: T5 j lvo5 {t5}.
  elim => [|t5 T5 IH] j lvo5 //.
  move => H_in_q.
  case: H_in_q => H_in_q //.
  rewrite -/(In_queue _ _) -/(init_queue _) in H_in_q.
  by contradict H_in_q.
- (* init_in *)
  move => T5 T' i5 t5 q' H_ok H_fresh H_eq.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_bef j lvo5.
  rewrite H_eq /=.
  case (eq_i j i5) => H_eq'.
    left.
    rewrite H_eq' => H_in_q.
    have H_in': In t5_before (T5 ++ T') by apply in_or_app; right.
    have H_or := in_queue_status_then_new _ H_ok _ H_in' _ _ H_in_q.
    case: H_or => H_or.
      contradict H_or.
      exact: (fresh_new_not_in_queue_bfs _ H_ok).
    contradict H_or.
    exact: (fresh_not_in_adj_bfs _ H_ok).
  by right; split; first by move => H_eq''; injection H_eq''.
- (* fail *)
  move => T5 i5 q5 I5 b5 L5 t5 q'.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t' := mk_nd_bfs _ _ _ _ _. 
  move => H_ok H_eq H_in H_or H_bef j lvo5.
  rewrite H_eq /=.
  by right; split.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5.
  by right; split.
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5.
  by right; split.
- (* timeout *)
  move => T5 i5 q5 I5 L5 t5 q' H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_eq H_in H_ins H_bef j lvo5.
  rewrite H_eq /=.
  by right; split.
Qed.

Lemma bfs_net_ok_queue_status_in_adj : forall (T5 : T), bfs_net_ok T5 -> 
  forall (t5 : t), In t5 T5 -> 
  forall (j : i) (lvo5 : lvo), first (bfs_mbox t5) = Some (msg_status j lvo5) -> 
  ISet.In j (bfs_adj t5).
Proof.
move => T5 H_ok t5 H_in.
pose P_curr (t5 : t) := forall (j : i) (lvo5 : lvo), first (bfs_mbox t5) = Some (msg_status j lvo5) -> ISet.In j (bfs_adj t5).
rewrite -/(P_curr _).
apply (P_inv_bfs T5); rewrite /P_curr // {H_ok T5 H_in t5 P_curr}.
- (* new_node *)
  rewrite /=.
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_eq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_fst'.
  case (eq_i i6 j) => H_eq'; first by rewrite H_eq'; apply ISetFacts.add_1.
  apply ISetFacts.add_2.
  apply dequeue_dequeued in H_deq.
  apply first_firstin in H_fst.
  apply first_firstin in H_fst'.
  have H_in: In t_before (t_before :: T5) by left.
  have H_all := in_after_all_status_new _ H_ok _ H_in i6 lvo5.
  rewrite /= in H_all.
  have H_notin: ~ In_queue (msg_new i6) q'.
    apply firstin_after_all_not_in with (a := (msg_status i6 lvo5)) => //.
    by apply dequeue_after_all with (q := q5).
  have H_notin': ~ In_queue (msg_new i6) q5.
    move => H_notin'.
    apply: H_notin.
    have H_neq: msg_new j <> msg_new i6 by injection => H_eq''; rewrite H_eq'' in H_eq'.
    exact: (dequeued_neq_in_before_in_after _ _ _ _ H_neq H_fst H_deq).
  apply firstin_in_queue in H_fst'.
  have H_in_q: In_queue (msg_status i6 lvo5) q5.
    exact: (dequeued_in_after_in_before _ q').
  by case (in_queue_status_then_new _ H_ok _ H_in _ _ H_in_q).
- (* fail_node *)
  rewrite /=.
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_eq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_fst'.
  apply first_firstin in H_fst.
  apply first_firstin in H_fst'.
  apply dequeue_dequeued in H_deq.
  have H_in: In t_before (t_before :: T5) by left.
  have H_all := in_after_all_status_new _ H_ok _ H_in i6 lvo5.
  have H_neq: j <> i6.
    rewrite /= in H_all.
    move => H_eq'.
    rewrite -H_eq' in H_fst'.
    suff H_suff: In_queue_after_all (msg_fail j) (msg_status j lvo5) q5.
      have H_neq: msg_fail j <> msg_status j lvo5 by [].
      have H_notin := firstin_after_all_not_in q5 (msg_fail j) (msg_status j lvo5) H_neq H_fst H_suff.
      apply: H_notin.
      have H_in_q: In_queue (msg_status j lvo5) q' by apply firstin_in_queue in H_fst'.
      exact: (dequeued_in_after_in_before _ q').
    by apply in_after_all_fail_status with (T5 := t_before :: T5) (t5 := t_before).
  apply ISetFacts.remove_2 => //.
  have H_notin: ~ In_queue (msg_new i6) q'.
    apply firstin_after_all_not_in with (a := (msg_status i6 lvo5)) => //.
    have H_neq': (msg_status i6 lvo5) <> (msg_new i6) by [].
    by apply dequeue_after_all with (q := q5).
  have H_notin': ~ In_queue (msg_new i6) q5.
    move => H_notin'.
    apply: H_notin.
    have H_neq': msg_fail j <> msg_new i6 by [].
    exact: (dequeued_neq_in_before_in_after _ _ _ _ H_neq' H_fst H_deq H_notin').
  apply firstin_in_queue in H_fst'.
  have H_in_q: In_queue (msg_status i6 lvo5) q5.
    exact: (dequeued_in_after_in_before _ q').
  by case (in_queue_status_then_new _ H_ok _ H_in _ _ H_in_q).
- (* fail_node *)
  rewrite /=.
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_eq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_fst'.
  apply first_firstin in H_fst.
  apply first_firstin in H_fst'.
  apply dequeue_dequeued in H_deq.
  have H_in: In t_before (t_before :: T5) by left.
  have H_all := in_after_all_status_new _ H_ok _ H_in i6 lvo5.
  have H_neq: j <> i6.
    rewrite /= in H_all.
    move => H_eq'.
    rewrite -H_eq' in H_fst'.
    suff H_suff: In_queue_after_all (msg_fail j) (msg_status j lvo5) q5.
      have H_neq: msg_fail j <> msg_status j lvo5 by [].
      have H_notin := firstin_after_all_not_in q5 (msg_fail j) (msg_status j lvo5) H_neq H_fst H_suff.
      apply: H_notin.
      have H_in_q: In_queue (msg_status j lvo5) q' by apply firstin_in_queue in H_fst'.
      exact: (dequeued_in_after_in_before _ q').
    by apply in_after_all_fail_status with (T5 := t_before :: T5) (t5 := t_before).
  apply ISetFacts.remove_2 => //.
  have H_notin: ~ In_queue (msg_new i6) q'.
    apply firstin_after_all_not_in with (a := (msg_status i6 lvo5)) => //.
    have H_neq': (msg_status i6 lvo5) <> (msg_new i6) by [].
    by apply dequeue_after_all with (q := q5).
  have H_notin': ~ In_queue (msg_new i6) q5.
    move => H_notin'.
    apply: H_notin.
    have H_neq': msg_fail j <> msg_new i6 by [].
    exact: (dequeued_neq_in_before_in_after _ _ _ _ H_neq' H_fst H_deq H_notin').
  apply firstin_in_queue in H_fst'.
  have H_in_q: In_queue (msg_status i6 lvo5) q5.
    exact: (dequeued_in_after_in_before _ q').
  by case (in_queue_status_then_new _ H_ok _ H_in _ _ H_in_q).
- (* fail_node *)
  rewrite /=.
  move => T5 q5 I5 b5 L5 q' j H_fst H_deq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_fst'.
  apply first_firstin in H_fst.
  apply first_firstin in H_fst'.
  apply dequeue_dequeued in H_deq.
  have H_in: In t_before (t_before :: T5) by left.
  have H_all := in_after_all_status_new _ H_ok _ H_in i6 lvo5.
  have H_neq: j <> i6.
    rewrite /= in H_all.
    move => H_eq'.
    rewrite -H_eq' in H_fst'.
    suff H_suff: In_queue_after_all (msg_fail j) (msg_status j lvo5) q5.
      have H_neq: msg_fail j <> msg_status j lvo5 by [].
      have H_notin := firstin_after_all_not_in q5 (msg_fail j) (msg_status j lvo5) H_neq H_fst H_suff.
      apply: H_notin.
      have H_in_q: In_queue (msg_status j lvo5) q' by apply firstin_in_queue in H_fst'.
      exact: (dequeued_in_after_in_before _ q').
    by apply in_after_all_fail_status with (T5 := t_before :: T5) (t5 := t_before).
  apply ISetFacts.remove_2 => //.
  have H_notin: ~ In_queue (msg_new i6) q'.
    apply firstin_after_all_not_in with (a := (msg_status i6 lvo5)) => //.
    have H_neq': (msg_status i6 lvo5) <> (msg_new i6) by [].
    by apply dequeue_after_all with (q := q5).
  have H_notin': ~ In_queue (msg_new i6) q5.
    move => H_notin'.
    apply: H_notin.
    have H_neq': msg_fail j <> msg_new i6 by [].
    exact: (dequeued_neq_in_before_in_after _ _ _ _ H_neq' H_fst H_deq H_notin').
  apply firstin_in_queue in H_fst'.
  have H_in_q: In_queue (msg_status i6 lvo5) q5.
    exact: (dequeued_in_after_in_before _ q').
  by case (in_queue_status_then_new _ H_ok _ H_in _ _ H_in_q).
- (* status_eq *)
  rewrite /=.
  move => T5 i5 q5 I5 b5 L5 q' j lv5 H_fst H_deq H_eq H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_fst'.
  apply first_firstin in H_fst.
  apply first_firstin in H_fst'.
  apply dequeue_dequeued in H_deq.
  have H_in: In t_before (t_before :: T5) by left.
  case (eq_i j i6) => H_eq'.
    rewrite -H_eq'.
    apply first_firstin in H_fst.
    move: H_fst.
    exact: H_bef.
  have H_all := in_after_all_status_new _ H_ok _ H_in i6 lvo5.
  have H_notin: ~ In_queue (msg_new i6) q'.
    apply firstin_after_all_not_in with (a := (msg_status i6 lvo5)) => //.
    have H_neq': (msg_status i6 lvo5) <> (msg_new i6) by [].
    by apply dequeue_after_all with (q := q5).
  have H_notin': ~ In_queue (msg_new i6) q5.
    move => H_notin'.
    apply: H_notin.
    have H_neq': msg_status j (Some lv5) <> msg_new i6 by [].
    exact: (dequeued_neq_in_before_in_after _ _ _ _ H_neq' H_fst H_deq H_notin').
  apply firstin_in_queue in H_fst'.
  have H_in_q: In_queue (msg_status i6 lvo5) q5.
    exact: (dequeued_in_after_in_before _ q').
  by case (in_queue_status_then_new _ H_ok _ H_in _ _ H_in_q).
- (* status_eq *)
  rewrite /=.
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_eq H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_fst'.
  apply first_firstin in H_fst.
  apply first_firstin in H_fst'.
  apply dequeue_dequeued in H_deq.
  have H_in: In t_before (t_before :: T5) by left.
  case (eq_i j i6) => H_eq'.
    rewrite -H_eq'.
    apply first_firstin in H_fst.
    move: H_fst.
    exact: H_bef.
  have H_all := in_after_all_status_new _ H_ok _ H_in i6 lvo5.
  have H_notin: ~ In_queue (msg_new i6) q'.
    apply firstin_after_all_not_in with (a := (msg_status i6 lvo5)) => //.
    have H_neq': (msg_status i6 lvo5) <> (msg_new i6) by [].
    by apply dequeue_after_all with (q := q5).
  have H_notin': ~ In_queue (msg_new i6) q5.
    move => H_notin'.
    apply: H_notin.
    have H_neq': msg_status j None <> msg_new i6 by [].
    exact: (dequeued_neq_in_before_in_after _ _ _ _ H_neq' H_fst H_deq H_notin').
  apply firstin_in_queue in H_fst'.
  have H_in_q: In_queue (msg_status i6 lvo5) q5.
    exact: (dequeued_in_after_in_before _ q').
  by case (in_queue_status_then_new _ H_ok _ H_in _ _ H_in_q).
- (* status_neq *)
  rewrite /=.
  move => T5 i5 q5 I5 b5 L5 q' j lv5 H_fst H_deq H_eq H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_fst'.
  apply first_firstin in H_fst.
  apply first_firstin in H_fst'.
  apply dequeue_dequeued in H_deq.
  have H_in: In t_before (t_before :: T5) by left.
  case (eq_i j i6) => H_eq'.
    rewrite -H_eq'.
    apply first_firstin in H_fst.
    move: H_fst.
    exact: H_bef.
  have H_all := in_after_all_status_new _ H_ok _ H_in i6 lvo5.
  have H_notin: ~ In_queue (msg_new i6) q'.
    apply firstin_after_all_not_in with (a := (msg_status i6 lvo5)) => //.
    have H_neq': (msg_status i6 lvo5) <> (msg_new i6) by [].
    by apply dequeue_after_all with (q := q5).
  have H_notin': ~ In_queue (msg_new i6) q5.
    move => H_notin'.
    apply: H_notin.
    have H_neq': msg_status j (Some lv5) <> msg_new i6 by [].
    exact: (dequeued_neq_in_before_in_after _ _ _ _ H_neq' H_fst H_deq H_notin').
  apply firstin_in_queue in H_fst'.
  have H_in_q: In_queue (msg_status i6 lvo5) q5.
    exact: (dequeued_in_after_in_before _ q').
  by case (in_queue_status_then_new _ H_ok _ H_in _ _ H_in_q).
- (* status_eq *)
  rewrite /=.
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_eq H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_fst'.
  apply first_firstin in H_fst.
  apply first_firstin in H_fst'.
  apply dequeue_dequeued in H_deq.
  have H_in: In t_before (t_before :: T5) by left.
  case (eq_i j i6) => H_eq'.
    rewrite -H_eq'.
    apply first_firstin in H_fst.
    move: H_fst.
    exact: H_bef.
  have H_all := in_after_all_status_new _ H_ok _ H_in i6 lvo5.
  have H_notin: ~ In_queue (msg_new i6) q'.
    apply firstin_after_all_not_in with (a := (msg_status i6 lvo5)) => //.
    have H_neq': (msg_status i6 lvo5) <> (msg_new i6) by [].
    by apply dequeue_after_all with (q := q5).
  have H_notin': ~ In_queue (msg_new i6) q5.
    move => H_notin'.
    apply: H_notin.
    have H_neq': msg_status j None <> msg_new i6 by [].
    exact: (dequeued_neq_in_before_in_after _ _ _ _ H_neq' H_fst H_deq H_notin').
  apply firstin_in_queue in H_fst'.
  have H_in_q: In_queue (msg_status i6 lvo5) q5.
    exact: (dequeued_in_after_in_before _ q').
  by case (in_queue_status_then_new _ H_ok _ H_in _ _ H_in_q).
- (* status_eq *)
  rewrite /=.
  move => T5 q5 I5 b5 L5 q' j lvo5 H_fst H_deq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo' H_fst'.
  apply first_firstin in H_fst.
  apply first_firstin in H_fst'.
  apply dequeue_dequeued in H_deq.
  have H_in: In t_before (t_before :: T5) by left.
  case (eq_i j i6) => H_eq'.
    rewrite -H_eq'.
    apply first_firstin in H_fst.
    move: H_fst.
    exact: H_bef.
  have H_all := in_after_all_status_new _ H_ok _ H_in i6 lvo'.
  have H_notin: ~ In_queue (msg_new i6) q'.
    apply firstin_after_all_not_in with (a := (msg_status i6 lvo')) => //.
    have H_neq': (msg_status i6 lvo') <> (msg_new i6) by [].
    by apply dequeue_after_all with (q := q5).
  have H_notin': ~ In_queue (msg_new i6) q5.
    move => H_notin'.
    apply: H_notin.
    have H_neq': msg_status j lvo5 <> msg_new i6 by [].
    exact: (dequeued_neq_in_before_in_after _ _ _ _ H_neq' H_fst H_deq H_notin').
  apply firstin_in_queue in H_fst'.
  have H_in_q: In_queue (msg_status i6 lvo') q5.
    exact: (dequeued_in_after_in_before _ q').
  by case (in_queue_status_then_new _ H_ok _ H_in _ _ H_in_q).
- (* init *)
  move => T5 T' i5 H_ok H_fresh j lvo5.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_fst.
  apply first_firstin in H_fst.
  apply firstin_in_queue in H_fst.
  rewrite /= in H_fst.
  contradict H_fst.
  move: T' j lvo5 {T5 i5 H_ok H_fresh t_after}. 
  elim => [|t5 T5 IH] j lvo5 H_in_q; first by inversion H_in_q.
  rewrite /= in H_in_q.
  case: H_in_q => H_in_q //.
  by contradict H_in_q.
- (* init_in *)
  move => T5 T' i5 t5 q' H_ok H_fresh H_eq.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_in H_bef j lvo5 H_fst'.
  rewrite H_eq in H_fst'.
  apply first_firstin in H_fst'.
  inversion H_fst'. 
  apply (H_bef _ lvo5).
  by apply first_firstin.
- (* fail *)
  move => T5 i5 q5 I5 b5 L5 t5 q'.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_eq H_in H_or H_bef j lvo5 H_fst'.
  apply first_firstin in H_fst'.
  rewrite H_eq in H_fst'.
  inversion H_fst'.
  apply (H_bef _ lvo5).
  by apply first_firstin.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t0_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_fst'.
  rewrite /= in H_fst'.
  rewrite /=.
  case (eq_i i6 j) => H_eq'; first by rewrite H_eq'; apply ISetFacts.add_1.
  apply ISetFacts.add_2.
  apply dequeue_dequeued in H_deq.
  apply first_firstin in H_fst.
  apply first_firstin in H_fst'.
  have H_in: In t0_before (t0_before :: t1_before :: T5) by left.
  have H_all := in_after_all_status_new _ H_ok _ H_in i6 lvo5.
  rewrite /= in H_all.
  have H_notin: ~ In_queue (msg_new i6) q''.
    apply firstin_after_all_not_in with (a := (msg_status i6 lvo5)) => //.
    by apply dequeue_after_all with (q := q5).
  have H_notin': ~ In_queue (msg_new i6) q5.
    move => H_notin'.
    apply: H_notin.
    have H_neq': msg_new j <> msg_new i6 by injection => H_eq''; rewrite H_eq'' in H_eq'.
    exact: (dequeued_neq_in_before_in_after _ _ _ _ H_neq' H_fst H_deq).
  apply firstin_in_queue in H_fst'.
  have H_in_q: In_queue (msg_status i6 lvo5) q5.
    exact: (dequeued_in_after_in_before _ q'').
  by case (in_queue_status_then_new _ H_ok _ H_in _ _ H_in_q).
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t1_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_fst'.
  apply first_firstin in H_fst'.
  rewrite /= in H_fst'.
  inversion H_fst'.
    rewrite -H /=.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    have H_or: ISet.In j (bfs_adj t0_before) \/ In_queue (msg_new j) q5 by right.
    have H_in: In t0_before (t0_before :: t1_before :: T5) by left.
    have H_in': In t1_before (t0_before :: t1_before :: T5) by right; left.
    have H_st := or_in_then_in_or_queue_bfs _ H_ok _ _ H_in H_in' H_or.
    rewrite /= -H0 in H_st.
    by case: H_st.
  rewrite /=.
  apply (H_bef _ lvo5).
  by apply first_firstin.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' H_fst H_deq H_neq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_fst'.
  rewrite /=.
  case (eq_i i6 j) => H_eq'; first by rewrite H_eq'; apply ISetFacts.add_1.
  apply ISetFacts.add_2.
  apply dequeue_dequeued in H_deq.
  apply first_firstin in H_fst.
  apply first_firstin in H_fst'.
  have H_in: In t_before (t_before :: T5) by left.
  have H_all := in_after_all_status_new _ H_ok _ H_in i6 lvo5.
  rewrite /= in H_all.
  have H_notin: ~ In_queue (msg_new i6) q'.
    apply firstin_after_all_not_in with (a := (msg_status i6 lvo5)) => //.
    by apply dequeue_after_all with (q := q5).
  have H_notin': ~ In_queue (msg_new i6) q5.
    move => H_notin'.
    apply: H_notin.
    have H_neq': msg_new j <> msg_new i6 by injection => H_eq''; rewrite H_eq'' in H_eq'.
    exact: (dequeued_neq_in_before_in_after _ _ _ _ H_neq' H_fst H_deq).
  apply firstin_in_queue in H_fst'.
  have H_in_q: In_queue (msg_status i6 lvo5) q5.
    exact: (dequeued_in_after_in_before _ q').
  by case (in_queue_status_then_new _ H_ok _ H_in _ _ H_in_q).
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t0_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_fst'.
  rewrite /=.
  case (eq_i i6 j) => H_eq'; first by rewrite H_eq'; apply ISetFacts.add_1.
  apply ISetFacts.add_2.
  apply dequeue_dequeued in H_deq.
  apply first_firstin in H_fst.
  apply first_firstin in H_fst'.
  have H_in: In t0_before (t0_before :: t1_before :: T5) by left.
  have H_all := in_after_all_status_new _ H_ok _ H_in i6 lvo5.
  rewrite /= in H_all.
  have H_notin: ~ In_queue (msg_new i6) q''.
    apply firstin_after_all_not_in with (a := (msg_status i6 lvo5)) => //.
    by apply dequeue_after_all with (q := q5).
  have H_notin': ~ In_queue (msg_new i6) q5.
    move => H_notin'.
    apply: H_notin.
    have H_neq': msg_new j <> msg_new i6 by injection => H_eq''; rewrite H_eq'' in H_eq'.
    exact: (dequeued_neq_in_before_in_after _ _ _ _ H_neq' H_fst H_deq).
  apply firstin_in_queue in H_fst'.
  have H_in_q: In_queue (msg_status i6 lvo5) q5.
    exact: (dequeued_in_after_in_before _ q'').
  by case (in_queue_status_then_new _ H_ok _ H_in _ _ H_in_q).
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t1_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_fst'.
  rewrite /=.
  apply first_firstin in H_fst'.
  rewrite /= in H_fst'.
  inversion H_fst'.    
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    have H_or: ISet.In j (bfs_adj t0_before) \/ In_queue (msg_new j) q5 by right.
    have H_in: In t0_before (t0_before :: t1_before :: T5) by left.
    have H_in': In t1_before (t0_before :: t1_before :: T5) by right; left.
    have H_st := or_in_then_in_or_queue_bfs _ H_ok _ _ H_in H_in' H_or.
    rewrite /= -H0 in H_st.
    by case: H_st.
  rewrite /=.
  apply (H_bef _ lvo5).
  by apply first_firstin.
- (* new *)
  move => T5 q5 I5 b5 L5 j q' H_fst H_deq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lvo5 H_fst'.
  rewrite /=.
  case (eq_i i6 j) => H_eq'; first by rewrite H_eq'; apply ISetFacts.add_1.
  apply ISetFacts.add_2.
  apply dequeue_dequeued in H_deq.
  apply first_firstin in H_fst.
  apply first_firstin in H_fst'.
  have H_in: In t_before (t_before :: T5) by left.
  have H_all := in_after_all_status_new _ H_ok _ H_in i6 lvo5.
  rewrite /= in H_all.
  have H_notin: ~ In_queue (msg_new i6) q'.
    apply firstin_after_all_not_in with (a := (msg_status i6 lvo5)) => //.
    by apply dequeue_after_all with (q := q5).
  have H_notin': ~ In_queue (msg_new i6) q5.
    move => H_notin'.
    apply: H_notin.
    have H_neq': msg_new j <> msg_new i6 by injection => H_eq''; rewrite H_eq'' in H_eq'.
    exact: (dequeued_neq_in_before_in_after _ _ _ _ H_neq' H_fst H_deq).
  apply firstin_in_queue in H_fst'.
  have H_in_q: In_queue (msg_status i6 lvo5) q5.
    exact: (dequeued_in_after_in_before _ q').
  by case (in_queue_status_then_new _ H_ok _ H_in _ _ H_in_q).
- (* broadcast *)
  move => T5 i5 q5 I5 L5 t5 q' H_neq.
  set t' := mk_nd_bfs _ _ _ _ _.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_eq H_in H_ins H_bef j lvo5 H_fst'.  
  have H_in': In t5_before (t' :: T5) by right.
  apply first_firstin in H_fst'. 
  rewrite H_eq /= in H_fst'.
  inversion H_fst'.    
    rewrite -H.
    have H_or: ISet.In (bfs_ident t5) I5 \/ In_queue (msg_new (bfs_ident t5)) q5 by left.
    have H_in_t': In t' (t' :: T5) by left.
    have H_st := or_in_then_in_or_queue_bfs _ H_ok _ _ H_in_t' H_in' H_or.
    rewrite /= -H0 in H_st.
    by case: H_st.
 apply (H_bef _ lvo5).
 by apply first_firstin.
Qed.

Lemma bfs_net_ok_notins_levels_bot : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 -> 
  forall (j : i), ~ ISet.In j (bfs_adj t5) -> 
  IMap.find j (bfs_levels t5) = None.
Proof.
move => T5 H_ok t5 H_in.
pose P_curr (t5 : t) := forall j : i, ~ ISet.In j (bfs_adj t5) -> IMap.find (elt:=lv) j (bfs_levels t5) = None.
rewrite -/(P_curr _).
apply (P_inv_bfs T5); rewrite /P_curr //= {H_ok T5 H_in t5 P_curr}; auto with set.
- (* fail *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 H_ins.
  case (eq_i j i6) => H_eq; first by rewrite H_eq IMapFacts.remove_eq_o.
  rewrite IMapFacts.remove_neq_o => //.
  apply H_bef.
  move => H_ins'.
  case: H_ins.
  exact: ISetFacts.remove_2.
- (* fail *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 H_ins.
  case (eq_i j i6) => H_eq; first by rewrite H_eq IMapFacts.remove_eq_o.
  rewrite IMapFacts.remove_neq_o => //.
  apply H_bef.
  move => H_ins'.
  case: H_ins.
  exact: ISetFacts.remove_2.
- (* fail *)
  move => T5 q5 I5 b5 L5 q' j H_fst H_deq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 H_ins.
  by apply (bfs_net_ok_root_levels_bot _ H_ok t_before); first by left.
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 H_ins.
  have H_in': t_before = t_before \/ In t_before T5 by left.
  case (eq_i j i6) => H_eq.      
      have H_ins' := bfs_net_ok_queue_status_in_adj _ H_ok _ H_in' _ _ H_fst.
      by rewrite H_eq in H_ins'.
  rewrite IMapFacts.add_neq_o => //.
  exact: H_bef.
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 H_ins.
  case (eq_i j i6) => H_eq; first by rewrite H_eq IMapFacts.remove_eq_o.
  rewrite IMapFacts.remove_neq_o => //.
  exact: H_bef.
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 H_ins.
  have H_in': t_before = t_before \/ In t_before T5 by left.
  case (eq_i j i6) => H_eq.      
    have H_ins' := bfs_net_ok_queue_status_in_adj _ H_ok _ H_in' _ _ H_fst.
    by rewrite H_eq in H_ins'.
  rewrite IMapFacts.add_neq_o => //.
  exact: H_bef.
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 H_ins.
  case (eq_i j i6) => H_eq; first by rewrite H_eq IMapFacts.remove_eq_o.
  rewrite IMapFacts.remove_neq_o => //.
  exact: H_bef.
Qed.

Lemma bfs_net_ok_nodup : forall (T5 : T),
  bfs_net_ok T5 ->
  NoDupA eq_ident T5.
Proof.
move => T5 H_ok.
apply project_churn_bfs_ok in H_ok.
have H_ex := churn_net_ok_nodup _ H_ok.
move: T5 H_ex {H_ok}.
elim => [|t5 T5 IH] //=.
rewrite /project_churn_bfs_node /=.
set s5 := mk_nd_churn _ _ _.
move => H_nd.
inversion H_nd; subst.
apply IH in H2.
apply NoDupA_cons => //.
move => H_in.
contradict H1.
apply InA_alt in H_in as [t' [H_eq H_in]].
inversion H_eq; subst.
apply in_split in H_in as [T' [T0 H_eq']].
rewrite H_eq' project_churn_bfs_distr /= /project_churn_bfs_node.
set s' := mk_nd_churn _ _ _.
apply InA_alt.
exists s'.
split => //.
apply in_or_app.
by right; left.
Qed.

Lemma bfs_net_ok_root_status_in_queue : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  forall (lvo5 : lvo), In_queue (msg_status 0 lvo5) (bfs_mbox t5) ->
  lvo5 = Some 0.
Proof.
move => T5 H_ok t5 H_in.
pose P_curr (t5 : t) := forall (lvo5 : lvo), In_queue (msg_status 0 lvo5) (bfs_mbox t5) -> lvo5 = Some 0.
rewrite -/(P_curr _).
apply (P_inv_bfs T5); rewrite /P_curr //= {H_ok T5 H_in t5 P_curr}; eauto with queue_in.
- (* init *)
  move => T5 T' i5 H_ok H_fresh lvo5 H_in_q {H_ok H_fresh T5 i5}.
  contradict H_in_q.
  move: T' lvo5.
  elim => [|t5 T5 IH] lvo5 H_not; first by inversion H_not.
  rewrite /= in H_not.
  case: H_not => H_not //.
  by contradict H_not.
- (* init *)
  move => T5 T' i5 t5 q5 H_ok H_fresh H_eq.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_bef lvo5 H_in_q.
  rewrite H_eq /= in H_in_q.
  case: H_in_q => H_in_q //.
  exact: H_bef.
- (* fail *)
  move => T5 i5 q5 I5 b5 L5 t5 q'.
  set t' := mk_nd_bfs _ _ _ _ _.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_eq H_in H_or H_bef lvo5 H_in_q.
  rewrite H_eq /= in H_in_q.
  case: H_in_q => H_in_q //.
  exact: H_bef.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef lvo5 H_in_q.
  case: H_in_q => H_in_q; first by injection H_in_q => H_eq H_eq'; rewrite H_eq' in H_neq.
  exact: H_bef.
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef lvo5 H_in_q.
  case: H_in_q => H_in_q; first by injection H_in_q => H_eq'; rewrite H_eq'.
  exact: H_bef.
- (* timeout *)
  move => T5 i5 q5 I5 L5 t5 q' H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_eq H_in H_ins H_bef lvo5 H_in_q.
  rewrite H_eq /= in H_in_q.
  case: H_in_q => H_in_q.
    injection H_in_q => H_eq' H_eq''.
    by rewrite H_eq'' in H_neq.
  exact: H_bef.
Qed.

Lemma bfs_net_ok_root_broadcast_false : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  bfs_ident t5 = 0 ->
  bfs_broadcast t5 = false.
Proof.
move => T5 H_ok t5 H_in.
pose P_curr (t5 : t) := bfs_ident t5 = 0 -> bfs_broadcast t5 = false.
rewrite -/(P_curr _).
by apply (P_inv_bfs T5); rewrite /P_curr //= {H_ok T5 H_in t5 P_curr}.
Qed.

Section DualNodeInvBfs.

Variable T5 : T.

Hypothesis H_ok : bfs_net_ok T5.

Variable t5 t' : t.

Hypothesis H_in_t5 : In t5 T5.

Hypothesis H_in_t' : In t' T5.

Variable P : t -> t -> Prop.

Hypothesis new_node_dual : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' (ISet.add j I5) b5 L5 in
  first q5 = Some (msg_new j) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = None ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  P t_before t_before ->
  P t_after t_after.

Hypothesis new_node_dual_in_fst : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (t' : t),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' (ISet.add j I5) b5 L5 in
  first q5 = Some (msg_new j) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = None ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  In t' T5 ->
  P t_before t' ->
  P t_after t'.

Hypothesis new_node_dual_in_snd : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (t5 : t),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' (ISet.add j I5) b5 L5 in
  first q5 = Some (msg_new j) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = None ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  In t5 T5 ->
  P t5 t_before ->
  P t5 t_after.

Hypothesis fail_eq_node_dual : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' (ISet.remove j I5) b5 (IMap.remove j L5) in
  first q5 = Some (msg_fail j) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = level (ISet.remove j I5) (IMap.remove j L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  P t_before t_before ->
  P t_after t_after.

Hypothesis fail_eq_node_dual_in_fst : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (t' : t),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' (ISet.remove j I5) b5 (IMap.remove j L5) in
  first q5 = Some (msg_fail j) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = level (ISet.remove j I5) (IMap.remove j L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  In t' T5 ->
  P t_before t' ->
  P t_after t'.

Hypothesis fail_eq_node_dual_in_snd : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (t5 : t),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' (ISet.remove j I5) b5 (IMap.remove j L5) in
  first q5 = Some (msg_fail j) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = level (ISet.remove j I5) (IMap.remove j L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  In t5 T5 ->
  P t5 t_before ->
  P t5 t_after.

Hypothesis fail_neq_node_dual : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' (ISet.remove j I5) true (IMap.remove j L5) in
  first q5 = Some (msg_fail j) -> 
  dequeue q5 = Some q' ->
  level I5 L5 <> level (ISet.remove j I5) (IMap.remove j L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  P t_before t_before ->
  P t_after t_after.

Hypothesis fail_neq_node_dual_in_fst : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (t' : t),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' (ISet.remove j I5) true (IMap.remove j L5) in
  first q5 = Some (msg_fail j) -> 
  dequeue q5 = Some q' ->
  level I5 L5 <> level (ISet.remove j I5) (IMap.remove j L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  In t' T5 ->
  P t_before t' ->
  P t_after t'.

Hypothesis fail_neq_node_dual_in_snd : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (t5 : t),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' (ISet.remove j I5) true (IMap.remove j L5) in
  first q5 = Some (msg_fail j) -> 
  dequeue q5 = Some q' ->
  level I5 L5 <> level (ISet.remove j I5) (IMap.remove j L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  In t5 T5 ->
  P t5 t_before ->
  P t5 t_after.

Hypothesis fail_root_node_dual : forall (T5 : T) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i),
  let t_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs 0 q' (ISet.remove j I5) b5 L5 in
  first q5 = Some (msg_fail j) -> 
  dequeue q5 = Some q' ->
  bfs_net_ok (t_before :: T5) ->
  P t_before t_before ->
  P t_after t_after.

Hypothesis fail_root_node_dual_in_fst : forall (T5 : T) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (t' : t),
  let t_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs 0 q' (ISet.remove j I5) b5 L5 in
  first q5 = Some (msg_fail j) -> 
  dequeue q5 = Some q' ->
  bfs_net_ok (t_before :: T5) ->
  In t' T5 ->
  P t_before t' ->
  P t_after t'.

Hypothesis fail_root_node_dual_in_snd : forall (T5 : T) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (t5 : t),
  let t_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs 0 q' (ISet.remove j I5) b5 L5 in
  first q5 = Some (msg_fail j) -> 
  dequeue q5 = Some q' ->
  bfs_net_ok (t_before :: T5) ->
  In t5 T5 ->
  P t5 t_before ->
  P t5 t_after.

Hypothesis status_eq_node_dual : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (lv5 : lv),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' I5 b5 (IMap.add j lv5 L5) in
  first q5 = Some (msg_status j (Some lv5)) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = level I5 (IMap.add j lv5 L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  P t_before t_before ->
  P t_after t_after.

Hypothesis status_eq_node_dual_in_fst : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (lv5 : lv) (t' : t),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' I5 b5 (IMap.add j lv5 L5) in
  first q5 = Some (msg_status j (Some lv5)) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = level I5 (IMap.add j lv5 L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  In t' T5 ->
  P t_before t' ->
  P t_after t'.

Hypothesis status_eq_node_dual_in_snd : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (lv5 : lv) (t5 : t),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' I5 b5 (IMap.add j lv5 L5) in
  first q5 = Some (msg_status j (Some lv5)) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = level I5 (IMap.add j lv5 L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  In t5 T5 ->
  P t5 t_before ->
  P t5 t_after.

Hypothesis status_eq_bot_node_dual : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' I5 b5 (IMap.remove j L5) in
  first q5 = Some (msg_status j None) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = level I5 (IMap.remove j L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  P t_before t_before ->
  P t_after t_after.

Hypothesis status_eq_bot_node_dual_in_fst : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (t' : t),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' I5 b5 (IMap.remove j L5) in
  first q5 = Some (msg_status j None) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = level I5 (IMap.remove j L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  In t' T5 ->
  P t_before t' ->
  P t_after t'.

Hypothesis status_eq_bot_node_dual_in_snd : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (t5 : t),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' I5 b5 (IMap.remove j L5) in
  first q5 = Some (msg_status j None) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = level I5 (IMap.remove j L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  In t5 T5 ->
  P t5 t_before ->
  P t5 t_after.

Hypothesis status_neq_node_dual : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (lv5 : lv),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' I5 true (IMap.add j lv5 L5) in
  first q5 = Some (msg_status j (Some lv5)) -> 
  dequeue q5 = Some q' ->
  level I5 L5 <> level I5 (IMap.add j lv5 L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  P t_before t_before ->
  P t_after t_after.

Hypothesis status_neq_node_dual_in_fst : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (lv5 : lv) (t' : t),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' I5 true (IMap.add j lv5 L5) in
  first q5 = Some (msg_status j (Some lv5)) -> 
  dequeue q5 = Some q' ->
  level I5 L5 <> level I5 (IMap.add j lv5 L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  In t' T5 ->
  P t_before t' ->
  P t_after t'.

Hypothesis status_neq_node_dual_in_snd : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (lv5 : lv) (t5 : t),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' I5 true (IMap.add j lv5 L5) in
  first q5 = Some (msg_status j (Some lv5)) -> 
  dequeue q5 = Some q' ->
  level I5 L5 <> level I5 (IMap.add j lv5 L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  In t5 T5 ->
  P t5 t_before ->
  P t5 t_after.

Hypothesis status_neq_bot_node_dual : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' I5 true (IMap.remove j L5) in
  first q5 = Some (msg_status j None) -> 
  dequeue q5 = Some q' ->
  level I5 L5 <> level I5 (IMap.remove j L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  P t_before t_before ->
  P t_after t_after.

Hypothesis status_neq_bot_node_dual_in_fst : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (t' : t),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' I5 true (IMap.remove j L5) in
  first q5 = Some (msg_status j None) -> 
  dequeue q5 = Some q' ->
  level I5 L5 <> level I5 (IMap.remove j L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  In t' T5 ->
  P t_before t' ->
  P t_after t'.

Hypothesis status_neq_bot_node_dual_in_snd : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (t5 : t),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' I5 true (IMap.remove j L5) in
  first q5 = Some (msg_status j None) -> 
  dequeue q5 = Some q' ->
  level I5 L5 <> level I5 (IMap.remove j L5) ->
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  In t5 T5 ->
  P t5 t_before ->
  P t5 t_after.

Hypothesis status_root_node_dual : forall (T5 : T) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (lvo5 : lvo),
  let t_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs 0 q' I5 b5 L5 in
  first q5 = Some (msg_status j lvo5) -> 
  dequeue q5 = Some q' ->
  bfs_net_ok (t_before :: T5) ->
  P t_before t_before ->
  P t_after t_after.

Hypothesis status_root_node_dual_in_fst : forall (T5 : T) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (lvo5 : lvo) (t' : t),
  let t_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs 0 q' I5 b5 L5 in
  first q5 = Some (msg_status j lvo5) -> 
  dequeue q5 = Some q' ->
  bfs_net_ok (t_before :: T5) ->
  In t' T5 ->
  P t_before t' ->
  P t_after t'.

Hypothesis status_root_node_dual_in_snd : forall (T5 : T) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (lvo5 : lvo) (t5 : t),
  let t_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs 0 q' I5 b5 L5 in
  first q5 = Some (msg_status j lvo5) -> 
  dequeue q5 = Some q' ->
  bfs_net_ok (t_before :: T5) ->
  In t5 T5 ->
  P t5 t_before ->
  P t5 t_after.

Hypothesis init_dual : forall (T5 T' : T) (i5 : i),
  let t_after := mk_nd_bfs i5 (init_queue T') ISet.empty false (IMap.empty lv) in
  bfs_net_ok (T5 ++ T') ->
  fresh i5 (T5 ++ T') ->
  P t_after t_after.

Hypothesis init_dual_in_fst : forall (T5 T' : T) (i5 : i) (t' : t),
  let t_after := mk_nd_bfs i5 (init_queue T') ISet.empty false (IMap.empty lv) in
  bfs_net_ok (T5 ++ T') ->
  fresh i5 (T5 ++ T') ->
  In t' T5 ->
  P t_after t'.

Hypothesis init_dual_in_snd : forall (T5 T' : T) (i5 : i) (t5 : t),
  let t_after := mk_nd_bfs i5 (init_queue T') ISet.empty false (IMap.empty lv) in
  bfs_net_ok (T5 ++ T') ->
  fresh i5 (T5 ++ T') ->
  In t5 T5 ->
  P t5 t_after.

Hypothesis init_dual_in_trd : forall (T5 : T) (T' : T) (i5 : i) (t' : t) (q5 : q),
  let t_after := mk_nd_bfs i5 (init_queue T') ISet.empty false (IMap.empty lv) in
  let t'_before := mk_nd_bfs (bfs_ident t') q5 (bfs_adj t') (bfs_broadcast t') (bfs_levels t') in
  bfs_net_ok (T5 ++ T') ->
  fresh i5 (T5 ++ T') ->
  bfs_mbox t' = queue_enqueue q5 (msg_new i5) ->
  In t'_before T' ->
  P t_after t'.

Hypothesis init_dual_in_fft : forall (T5 : T) (T' : T) (i5 : i) (q5 : q) (t5 t' : t),
  let t_after := mk_nd_bfs i5 (init_queue T') ISet.empty false (IMap.empty lv) in
  let t'_before := mk_nd_bfs (bfs_ident t') q5 (bfs_adj t') (bfs_broadcast t') (bfs_levels t') in
  bfs_net_ok (T5 ++ T') ->
  fresh i5 (T5 ++ T') ->
  bfs_mbox t' = queue_enqueue q5 (msg_new i5) ->
  In t'_before T' ->
  In t5 T5 ->
  P t5 t'_before ->
  P t5 t'.

Hypothesis init_dual_in_sth : forall (T5 : T) (T' : T) (i5 : i) (q5 : q) (t5 : t),
  let t_after := mk_nd_bfs i5 (init_queue T') ISet.empty false (IMap.empty lv) in
  let t5_before := mk_nd_bfs (bfs_ident t5) q5 (bfs_adj t5) (bfs_broadcast t5) (bfs_levels t5) in
  bfs_net_ok (T5 ++ T') ->
  fresh i5 (T5 ++ T') ->
  bfs_mbox t5 = queue_enqueue q5 (msg_new i5) ->
  In t5_before T' ->
  P t5 t_after.

Hypothesis init_dual_in_svt : forall (T5 : T) (T' : T) (i5 : i) (q5 : q) (t5 t' : t),
  let t5_before := mk_nd_bfs (bfs_ident t5) q5 (bfs_adj t5) (bfs_broadcast t5) (bfs_levels t5) in
  bfs_net_ok (T5 ++ T') ->
  fresh i5 (T5 ++ T') ->
  bfs_mbox t5 = queue_enqueue q5 (msg_new i5) ->
  In t5_before T' ->
  In t' T5 ->
  P t5_before t' ->
  P t5 t'.

Hypothesis init_dual_in_eth : forall (T5 : T) (T' : T) (i5 : i) (q5 q' : q) (t5 t' : t),
  let t5_before := mk_nd_bfs (bfs_ident t5) q5 (bfs_adj t5) (bfs_broadcast t5) (bfs_levels t5) in
  let t'_before := mk_nd_bfs (bfs_ident t') q' (bfs_adj t') (bfs_broadcast t') (bfs_levels t') in
  bfs_net_ok (T5 ++ T') ->
  fresh i5 (T5 ++ T') ->
  bfs_mbox t5 = queue_enqueue q5 (msg_new i5) ->
  bfs_mbox t' = queue_enqueue q' (msg_new i5) ->
  In t5_before T' ->
  In t'_before T' ->
  P t5_before t'_before ->
  P t5 t'.

Hypothesis fail_dual_in_fst : forall (T5 : T) (i5 : i) (q' : q) (I5 : I) (b5 : b) (L5 : L) (t5 t6 : t) (q5 q6 : q),
  let t' := mk_nd_bfs i5 q' I5 b5 L5 in
  let t5_before := mk_nd_bfs (bfs_ident t5) q5 (bfs_adj t5) (bfs_broadcast t5) (bfs_levels t5) in
  let t6_before := mk_nd_bfs (bfs_ident t6) q6 (bfs_adj t6) (bfs_broadcast t6) (bfs_levels t6) in
  bfs_net_ok (t' :: T5) ->
  bfs_mbox t5 = queue_enqueue q5 (msg_fail i5) ->
  bfs_mbox t6 = queue_enqueue q6 (msg_fail i5) ->
  In t5_before T5 ->
  In t6_before T5 ->
  P t5_before t6_before ->
  P t5 t6.

Hypothesis fail_dual_in_snd : forall (T5 : T) (i5 : i) (q' : q) (I5 : I) (b5 : b) (L5 : L) (t5 t6 : t) (q5 : q),
  let t' := mk_nd_bfs i5 q' I5 b5 L5 in
  let t5_before := mk_nd_bfs (bfs_ident t5) q5 (bfs_adj t5) (bfs_broadcast t5) (bfs_levels t5) in
  bfs_net_ok (t' :: T5) ->
  bfs_mbox t5 = queue_enqueue q5 (msg_fail i5) ->
  In t5_before T5 ->
  In t6 T5 ->
  P t5_before t6 ->
  P t5 t6.

Hypothesis fail_dual_in_trd : forall (T5 : T) (i5 : i) (q' : q) (I5 : I) (b5 : b) (L5 : L) (t5 t6 : t) (q6 : q),
  let t' := mk_nd_bfs i5 q' I5 b5 L5 in
  let t6_before := mk_nd_bfs (bfs_ident t6) q6 (bfs_adj t6) (bfs_broadcast t6) (bfs_levels t6) in
  bfs_net_ok (t' :: T5) ->
  bfs_mbox t6 = queue_enqueue q6 (msg_fail i5) ->
  In t5 T5 ->
  In t6_before T5 ->
  P t5 t6_before ->
  P t5 t6.

Hypothesis new_new_dual_fst : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q) (lv5 : lv),
  let t0_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t1_before := mk_nd_bfs j q' I' b' L' in
  let t0_after := mk_nd_bfs i5 q'' (ISet.add j I5) b5 L5 in
  let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status i5 (Some lv5))) I' b' L' in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q'' ->
  level I5 L5 = Some lv5 ->
  i5 <> 0 ->  
  bfs_net_ok (t0_before :: t1_before :: T5) ->
  P t0_before t0_before ->
  P t0_after t0_after.

Hypothesis new_new_dual_snd : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q) (lv5 : lv),
  let t0_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t1_before := mk_nd_bfs j q' I' b' L' in
  let t0_after := mk_nd_bfs i5 q'' (ISet.add j I5) b5 L5 in
  let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status i5 (Some lv5))) I' b' L' in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q'' ->
  level I5 L5 = Some lv5 ->
  i5 <> 0 ->
  bfs_net_ok (t0_before :: t1_before :: T5) ->
  P t0_before t1_before ->
  P t0_after t1_after.

Hypothesis new_new_dual_trd : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q) (lv5 : lv),
  let t0_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t1_before := mk_nd_bfs j q' I' b' L' in
  let t0_after := mk_nd_bfs i5 q'' (ISet.add j I5) b5 L5 in
  let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status i5 (Some lv5))) I' b' L' in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q'' ->
  level I5 L5 = Some lv5 ->
  i5 <> 0 ->
  bfs_net_ok (t0_before :: t1_before :: T5) ->
  P t1_before t0_before ->
  P t1_after t0_after.

Hypothesis new_new_dual_fth : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q) (lv5 : lv),
  let t0_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t1_before := mk_nd_bfs j q' I' b' L' in
  let t0_after := mk_nd_bfs i5 q'' (ISet.add j I5) b5 L5 in
  let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status i5 (Some lv5))) I' b' L' in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q'' ->
  level I5 L5 = Some lv5 ->
  i5 <> 0 ->
  bfs_net_ok (t0_before :: t1_before :: T5) ->
  P t1_before t1_before ->
  P t1_after t1_after.

Hypothesis new_new_dual_in_fst : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q) (lv5 : lv) (t' : t),
  let t0_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t1_before := mk_nd_bfs j q' I' b' L' in
  let t0_after := mk_nd_bfs i5 q'' (ISet.add j I5) b5 L5 in
  let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status i5 (Some lv5))) I' b' L' in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q'' ->
  level I5 L5 = Some lv5 ->
  i5 <> 0 ->
  bfs_net_ok (t0_before :: t1_before :: T5) ->
  In t' T5 ->
  P t0_before t' ->
  P t0_after t'.

Hypothesis new_new_dual_in_snd : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q) (lv5 : lv) (t' : t),
  let t0_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t1_before := mk_nd_bfs j q' I' b' L' in
  let t0_after := mk_nd_bfs i5 q'' (ISet.add j I5) b5 L5 in
  let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status i5 (Some lv5))) I' b' L' in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q'' ->
  level I5 L5 = Some lv5 ->
  i5 <> 0 ->
  bfs_net_ok (t0_before :: t1_before :: T5) ->
  In t' T5 ->
  P t1_before t' ->
  P t1_after t'.

Hypothesis new_new_dual_in_trd : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q) (lv5 : lv) (t5 : t),
  let t0_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t1_before := mk_nd_bfs j q' I' b' L' in
  let t0_after := mk_nd_bfs i5 q'' (ISet.add j I5) b5 L5 in
  let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status i5 (Some lv5))) I' b' L' in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q'' ->
  level I5 L5 = Some lv5 ->
  i5 <> 0 ->
  bfs_net_ok (t0_before :: t1_before :: T5) ->
  In t5 T5 ->
  P t5 t0_before ->
  P t5 t0_after.

Hypothesis new_new_dual_in_fth : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q) (lv5 : lv) (t5 : t),
  let t0_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t1_before := mk_nd_bfs j q' I' b' L' in
  let t0_after := mk_nd_bfs i5 q'' (ISet.add j I5) b5 L5 in
  let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status i5 (Some lv5))) I' b' L' in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q'' ->
  level I5 L5 = Some lv5 ->
  i5 <> 0 ->
  bfs_net_ok (t0_before :: t1_before :: T5) ->
  In t5 T5 ->
  P t5 t1_before ->
  P t5 t1_after.

Hypothesis new_ex_node_dual : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (lv5 : lv),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' (ISet.add j I5) b5 L5 in
  first q5 = Some (msg_new j) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = Some lv5 ->
  i5 <> 0 ->
  ~ (exists t5 : t, In t5 T5 /\ bfs_ident t5 = j) ->
  bfs_net_ok (t_before :: T5) ->
  P t_before t_before ->
  P t_after t_after.

Hypothesis new_ex_node_dual_in_fst : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (lv5 : lv) (t' : t),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' (ISet.add j I5) b5 L5 in
  first q5 = Some (msg_new j) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = Some lv5 ->
  i5 <> 0 ->
  ~ (exists t5 : t, In t5 T5 /\ bfs_ident t5 = j) ->
  bfs_net_ok (t_before :: T5) ->
  In t' T5 ->
  P t_before t' ->
  P t_after t'.

Hypothesis new_ex_node_dual_in_snd : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (lv5 : lv) (t5 : t),
  let t_before := mk_nd_bfs i5 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs i5 q' (ISet.add j I5) b5 L5 in
  first q5 = Some (msg_new j) -> 
  dequeue q5 = Some q' ->
  level I5 L5 = Some lv5 ->
  i5 <> 0 ->
  ~ (exists t5 : t, In t5 T5 /\ bfs_ident t5 = j) ->
  bfs_net_ok (t_before :: T5) ->
  In t5 T5 ->
  P t5 t_before ->
  P t5 t_after.

Hypothesis new_new_root_dual_fst : forall (T5 : T) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q),
  let t0_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t1_before := mk_nd_bfs j q' I' b' L' in
  let t0_after := mk_nd_bfs 0 q'' (ISet.add j I5) b5 L5 in
  let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status 0 (Some 0))) I' b' L' in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q'' ->
  bfs_net_ok (t0_before :: t1_before :: T5) ->
  P t0_before t0_before ->
  P t0_after t0_after.

Hypothesis new_new_root_dual_snd : forall (T5 : T) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q),
  let t0_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t1_before := mk_nd_bfs j q' I' b' L' in
  let t0_after := mk_nd_bfs 0 q'' (ISet.add j I5) b5 L5 in
  let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status 0 (Some 0))) I' b' L' in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q'' ->
  bfs_net_ok (t0_before :: t1_before :: T5) ->
  P t0_before t1_before ->
  P t0_after t1_after.

Hypothesis new_new_root_dual_trd : forall (T5 : T) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q),
  let t0_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t1_before := mk_nd_bfs j q' I' b' L' in
  let t0_after := mk_nd_bfs 0 q'' (ISet.add j I5) b5 L5 in
  let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status 0 (Some 0))) I' b' L' in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q'' ->
  bfs_net_ok (t0_before :: t1_before :: T5) ->
  P t1_before t0_before ->
  P t1_after t0_after.

Hypothesis new_new_root_dual_fth : forall (T5 : T) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q),
  let t0_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t1_before := mk_nd_bfs j q' I' b' L' in
  let t0_after := mk_nd_bfs 0 q'' (ISet.add j I5) b5 L5 in
  let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status 0 (Some 0))) I' b' L' in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q'' ->
  bfs_net_ok (t0_before :: t1_before :: T5) ->
  P t1_before t1_before ->
  P t1_after t1_after.

Hypothesis new_new_root_dual_in_fst : forall (T5 : T) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q) (t' : t),
  let t0_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t1_before := mk_nd_bfs j q' I' b' L' in
  let t0_after := mk_nd_bfs 0 q'' (ISet.add j I5) b5 L5 in
  let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status 0 (Some 0))) I' b' L' in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q'' ->
  bfs_net_ok (t0_before :: t1_before :: T5) ->
  In t' T5 ->
  P t0_before t' ->
  P t0_after t'.

Hypothesis new_new_root_dual_in_snd : forall (T5 : T) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q) (t' : t),
  let t0_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t1_before := mk_nd_bfs j q' I' b' L' in
  let t0_after := mk_nd_bfs 0 q'' (ISet.add j I5) b5 L5 in
  let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status 0 (Some 0))) I' b' L' in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q'' ->
  bfs_net_ok (t0_before :: t1_before :: T5) ->
  In t' T5 ->
  P t1_before t' ->
  P t1_after t'.

Hypothesis new_new_root_dual_in_trd : forall (T5 : T) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q) (t5 : t),
  let t0_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t1_before := mk_nd_bfs j q' I' b' L' in
  let t0_after := mk_nd_bfs 0 q'' (ISet.add j I5) b5 L5 in
  let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status 0 (Some 0))) I' b' L' in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q'' ->
  bfs_net_ok (t0_before :: t1_before :: T5) ->
  In t5 T5 ->
  P t5 t0_before ->
  P t5 t0_after.

Hypothesis new_new_root_dual_in_fth : forall (T5 : T) (q5 : q) (I5 : I) (b5 : b) (L5 : L) (j : i) (q' : q) (I' : I) (b' : b) (L' : L) (q'' : q) (t5 : t),
  let t0_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t1_before := mk_nd_bfs j q' I' b' L' in
  let t0_after := mk_nd_bfs 0 q'' (ISet.add j I5) b5 L5 in
  let t1_after := mk_nd_bfs j (queue_enqueue q' (msg_status 0 (Some 0))) I' b' L' in
  first q5 = Some (msg_new j) ->
  dequeue q5 = Some q'' ->
  bfs_net_ok (t0_before :: t1_before :: T5) ->
  In t5 T5 ->
  P t5 t1_before ->
  P t5 t1_after.

Hypothesis new_root_ex_node_dual : forall (T5 : T) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i),
  let t_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs 0 q' (ISet.add j I5) b5 L5 in
  first q5 = Some (msg_new j) -> 
  dequeue q5 = Some q' ->
  ~ (exists t5 : t, In t5 T5 /\ bfs_ident t5 = j) ->
  bfs_net_ok (t_before :: T5) ->
  P t_before t_before ->
  P t_after t_after.

Hypothesis new_root_ex_node_dual_in_fst : forall (T5 : T) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (t' : t),
  let t_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs 0 q' (ISet.add j I5) b5 L5 in
  first q5 = Some (msg_new j) -> 
  dequeue q5 = Some q' ->
  ~ (exists t5 : t, In t5 T5 /\ bfs_ident t5 = j) ->
  bfs_net_ok (t_before :: T5) ->
  In t' T5 ->
  P t_before t' ->
  P t_after t'.

Hypothesis new_root_ex_node_in_snd : forall (T5 : T) (q5 : q) (I5 : I) (b5 : bool) (L5 : L) (q' : q) (j : i) (t5 : t),
  let t_before := mk_nd_bfs 0 q5 I5 b5 L5 in
  let t_after := mk_nd_bfs 0 q' (ISet.add j I5) b5 L5 in
  first q5 = Some (msg_new j) -> 
  dequeue q5 = Some q' ->
  ~ (exists t5 : t, In t5 T5 /\ bfs_ident t5 = j) ->
  bfs_net_ok (t_before :: T5) ->
  In t5 T5 ->
  P t5 t_before ->
  P t5 t_after.

Hypothesis broadcast_dual_fst : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (L5 : L),
  let t_before := mk_nd_bfs i5 q5 I5 true L5 in
  let t_after := mk_nd_bfs i5 q5 I5 false L5 in
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  P t_before t_before ->
  P t_after t_after.

Hypothesis broadcast_dual_in_fst : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (L5 : L) (t5 : t) (q' : q),
  let t_before := mk_nd_bfs i5 q5 I5 true L5 in
  let t_after := mk_nd_bfs i5 q5 I5 false L5 in
  let t5_before := mk_nd_bfs (bfs_ident t5) q' (bfs_adj t5) (bfs_broadcast t5) (bfs_levels t5) in
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  bfs_mbox t5 = queue_enqueue q' (msg_status i5 (level I5 L5)) ->
  In t5_before T5 ->
  ISet.In (bfs_ident t5) I5 ->
  P t_before t5_before ->
  P t_after t5.

Hypothesis broadcast_dual_in_snd : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (L5 : L) (t5 : t),
  let t_before := mk_nd_bfs i5 q5 I5 true L5 in
  let t_after := mk_nd_bfs i5 q5 I5 false L5 in
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  In t5 T5 ->
  ~ ISet.In (bfs_ident t5) I5 ->
  P t_before t5 ->
  P t_after t5.

Hypothesis broadcast_dual_in_trd : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (L5 : L) (t5 : t) (q' : q),
  let t_before := mk_nd_bfs i5 q5 I5 true L5 in
  let t_after := mk_nd_bfs i5 q5 I5 false L5 in
  let t5_before := mk_nd_bfs (bfs_ident t5) q' (bfs_adj t5) (bfs_broadcast t5) (bfs_levels t5) in
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  bfs_mbox t5 = queue_enqueue q' (msg_status i5 (level I5 L5)) ->
  In t5_before T5 ->
  ISet.In (bfs_ident t5) I5 ->
  P t5_before t_before ->
  P t5 t_after.

Hypothesis broadcast_dual_in_fth : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (L5 : L) (t5 t' : t) (q' q'' : q),
  let t_before := mk_nd_bfs i5 q5 I5 true L5 in
  let t_after := mk_nd_bfs i5 q5 I5 false L5 in
  let t5_before := mk_nd_bfs (bfs_ident t5) q' (bfs_adj t5) (bfs_broadcast t5) (bfs_levels t5) in
  let t'_before := mk_nd_bfs (bfs_ident t') q'' (bfs_adj t') (bfs_broadcast t') (bfs_levels t') in
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  bfs_mbox t5 = queue_enqueue q' (msg_status i5 (level I5 L5)) ->
  bfs_mbox t' = queue_enqueue q'' (msg_status i5 (level I5 L5)) ->
  In t5_before T5 ->
  In t'_before T5 ->
  ISet.In (bfs_ident t5) I5 ->
  ISet.In (bfs_ident t') I5 ->
  P t5_before t'_before ->
  P t5 t'.

Hypothesis broadcast_dual_in_fft : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (L5 : L) (t5 : t) (t' : t) (q' : q),
  let t_before := mk_nd_bfs i5 q5 I5 true L5 in
  let t_after := mk_nd_bfs i5 q5 I5 false L5 in
  let t5_before := mk_nd_bfs (bfs_ident t5) q' (bfs_adj t5) (bfs_broadcast t5) (bfs_levels t5) in
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  bfs_mbox t5 = queue_enqueue q' (msg_status i5 (level I5 L5)) ->
  In t5_before T5 ->
  In t' T5 ->
  ISet.In (bfs_ident t5) I5 ->
  ~ ISet.In (bfs_ident t') I5 ->
  P t5_before t' ->
  P t5 t'.

Hypothesis broadcast_dual_in_sth : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (L5 : L) (t' : t),
  let t_before := mk_nd_bfs i5 q5 I5 true L5 in
  let t_after := mk_nd_bfs i5 q5 I5 false L5 in
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  In t' T5 ->
  ~ ISet.In (bfs_ident t') I5 ->
  P t' t_before ->
  P t' t_after.

Hypothesis broadcast_dual_in_svt : forall (T5 : T) (i5 : i) (q5 : q) (I5 : I) (L5 : L) (t5 : t) (t' : t) (q' : q),
  let t_before := mk_nd_bfs i5 q5 I5 true L5 in
  let t_after := mk_nd_bfs i5 q5 I5 false L5 in
  let t5_before := mk_nd_bfs (bfs_ident t5) q' (bfs_adj t5) (bfs_broadcast t5) (bfs_levels t5) in
  i5 <> 0 ->
  bfs_net_ok (t_before :: T5) ->
  bfs_mbox t5 = queue_enqueue q' (msg_status i5 (level I5 L5)) ->
  In t5_before T5 ->
  In t' T5 ->
  ISet.In (bfs_ident t5) I5 ->
  ~ ISet.In (bfs_ident t') I5 ->
  P t' t5_before ->
  P t' t5.

Theorem P_inv_dual_bfs : P t5 t'.
Proof.
move: T5 H_ok t5 t' H_in_t5 H_in_t'.
clear T5 H_ok t5 t' H_in_t5 H_in_t'.
move => T5.
elim => //.
move => T' T0 H_ok IH H_st_red.
inversion H_st_red; subst.
have H_ok' := bfs_net_ok_permutation _ _ H_ok H.
have IH': forall t5 t' : t, In t5 T'1 -> In t' T'1 -> P t5 t'.
  move => t5 t' H_in H_in'.
  apply Permutation_sym in H.
  by apply IH; apply: (Permutation_in _ H).
suff H_suff: forall t5 t' : t, In t5 T'2 -> In t' T'2 -> P t5 t'.
  move => t5 t' H_in H_in'.
  apply Permutation_sym in H1.
  by apply H_suff; apply: (Permutation_in _ H1).
clear IH H_st_red H H1 H_ok.
move: H_ok' H0 IH' => H_ok H_red IH.
inversion H_red; subst.
- (* init *)
  move: H_ok IH H H_red.
  clear H_ok.
  set t_after := mk_nd_bfs _ _ _ _ _.
  rewrite /=.
  move => H_ok IH H H_red.
  move => t5 t' H_in H_in'.
  case: H_in => H_in.
    rewrite -H_in.
    case: H_in' => H_in'; first by rewrite -H_in'; exact: (init_dual T1).
    apply in_app_or in H_in'.
    case: H_in' => H_in'.
      have H_inn': In t' (T1 ++ T'0) by apply in_or_app; left.
      exact: (init_dual_in_fst T1).
    apply in_enqueue_new in H_in' as [q' [H_eq H_in']].
    move: H_in'.
    rewrite /put_mbox /= /t_put_mbox /=.
    set t'_before := mk_nd_bfs _ _ _ _ _.
    move => H_in'.
    have H_inn: In t'_before (T1 ++ T'0) by apply in_or_app; right.
    exact: (init_dual_in_trd T1 _ _ _ q').
  apply in_app_or in H_in.
  case: H_in => H_in.
    case: H_in' => H_in'.
      rewrite -H_in'.
      have H_inn: In t5 (T1 ++ T'0) by apply in_or_app; left.
      exact: (init_dual_in_snd T1).
    apply in_app_or in H_in'.
    case: H_in' => H_in'; first by apply IH; apply in_or_app; left.
    apply in_enqueue_new in H_in' as [q' [H_eq H_in']].
    move: H_in'.
    rewrite /put_mbox /= /t_put_mbox /=.
    set t'_before := mk_nd_bfs _ _ _ _ _.
    move => H_in'.
    have H_inn': In t'_before (T1 ++ T'0) by apply in_or_app; right.
    have H_inn: In t5 (T1 ++ T'0) by apply in_or_app; left.
    have H_p := IH _ _ H_inn H_inn'.
    exact: (init_dual_in_fft T1 T'0 i5 q').
  apply in_enqueue_new in H_in as [q' [H_eq H_in]].
  move: H_in.
  rewrite /put_mbox /= /t_put_mbox /=.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_in.
  have H_inn: In t5_before (T1 ++ T'0) by apply in_or_app; right.
  case: H_in' => H_in'; first by rewrite -H_in'; exact: (init_dual_in_sth T1 _ _ q').
  apply in_app_or in H_in'.
  case: H_in' => H_in'.
    have H_inn': In t' (T1 ++ T'0) by apply in_or_app; left.
    have IH' := IH t5_before t' H_inn H_inn'.
    exact: (init_dual_in_svt T1 T'0 i5 q').
  apply in_enqueue_new in H_in' as [q5 [H_eq' H_in']].
  move: H_in'.
  rewrite /put_mbox /= /t_put_mbox /=.
  set t'_before := mk_nd_bfs _ _ _ _ _.
  move => H_in'.
  have H_inn': In t'_before (T1 ++ T'0) by apply in_or_app; right.
  have IH' := IH t5_before t'_before H_inn H_inn'.
  exact: (init_dual_in_eth T1 T'0 i5 q' q5).
- (* fail *)
  move: H_ok IH H_red.
  clear H_ok.
  set t' := mk_nd_bfs _ _ _ _ _.
  rewrite /=.
  move => H_ok IH H_red t5 t6 H_in H_in'.
  case (in_enqueue_fail T1 t5 i5 H_in) => H_or.
    move: H_or => [q' [H_eq [H_inn H_or]]].
    move: H_inn.
    rewrite /put_mbox /= /t_put_mbox /=.
    set t5_before := mk_nd_bfs _ _ _ _ _.
    move => H_inn.
    case (in_enqueue_fail T1 t6 i5 H_in') => H_or'.
      move: H_or' => [q6 [H_eq' [H_inn' H_or']]].
      move: H_inn'.
      rewrite /put_mbox /= /t_put_mbox /=.
      set t6_before := mk_nd_bfs _ _ _ _ _.
      move => H_inn'.
      have H_p: P t5_before t6_before by apply IH; right.
      exact: (fail_dual_in_fst T1 i5 q5 I5 b5 L5 _ _ q' q6).
    have H_p: P t5_before t6 by apply IH; right.
    exact: (fail_dual_in_snd T1 i5 q5 I5 b5 L5 _ _ q').
  case (in_enqueue_fail T1 t6 i5 H_in') => H_or'; last by apply IH; right.
  move: H_or' => [q6 [H_eq' [H_inn' H_or']]].
  move: H_inn'.
  rewrite /put_mbox /= /t_put_mbox /=.
  set t6_before := mk_nd_bfs _ _ _ _ _.
  move => H_inn'.
  have H_p: P t5 t6_before by apply IH; right.
  exact: (fail_dual_in_trd T1 i5 q5 I5 b5 L5 _ _ q6).
- (* new_not_exists *)
  move: H_ok IH H H_red.
  clear H_ok.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  rewrite /=.
  move => H_ok IH H H_red.
  move => t5 t' H_in H_in'.
  case: H_in => H_in.
    rewrite -H_in.
    case: H_in' => H_in'.
      rewrite -H_in'.
      have H_p: P t_before t_before by apply IH; left.
      exact: (new_ex_node_dual T1 _ q5 _ _ _ _ _ lv5).
    have H_p: P t_before t'.
      apply IH; first by left.
      by right.
    exact: (new_ex_node_dual_in_fst T1 _ q5 _ _ _ _ _ lv5).
  case: H_in' => H_in'.
    rewrite -H_in'.
    have H_p: P t5 t_before.
      apply IH; first by right.
      by left.
    exact: (new_ex_node_dual_in_snd T1 _ q5 _ _ _ _ _ lv5).
  apply IH; first by right.
  by right.
- (* new_root_not_exists *)
  move: H_ok IH H H_red.
  clear H_ok.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  rewrite /=.
  move => H_ok IH H H_red.
  move => t5 t' H_in H_in'.
  case: H_in => H_in.
    rewrite -H_in.
    case: H_in' => H_in'.
      rewrite -H_in'.
      have H_p: P t_before t_before by apply IH; left.
      exact: (new_root_ex_node_dual T1 q5).
    have H_p: P t_before t'.
      apply IH; first by left.
      by right.
    exact: (new_root_ex_node_dual_in_fst T1 q5).
  case: H_in' => H_in'.
    rewrite -H_in'.
    have H_p: P t5 t_before.
      apply IH; first by right.
      by left.
    exact: (new_root_ex_node_in_snd T1 q5).
  apply IH; first by right.
  by right.
- (* broadcast *)
  move: H_ok IH H H_red.
  clear H_ok.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  rewrite /=.
  move => H_ok IH H H_red.
  move => t5 t' H_in H_in'.
  case: H_in => H_in.
    rewrite -H_in.
    case: H_in' => H_in'.
      rewrite -H_in'.
      have H_p: P t_before t_before by apply IH; left.
      exact: (broadcast_dual_fst T1 _ q5).
    case (in_enqueue_status _ _ _ _ _ H_in') => H_or {H_in'}.
      move: H_or => [H_ex H_ins'].
      move: H_ex => [q'' [H_eq' H_in']].
      move: H_in'.
      rewrite /put_mbox /= /t_put_mbox /=.
      set t'_before := mk_nd_bfs _ _ _ _ _.
      move => H_in'.
      have H_p: P t_before t'_before.
        apply IH; first by left.
        by right.
      exact: (broadcast_dual_in_fst T1 _ q5 _ _ _ q'').
    move: H_or => [H_in' H_ins].
    have H_p: P t_before t'.
      apply IH; first by left.
      by right.
    exact: (broadcast_dual_in_snd T1 _ q5).
  case (in_enqueue_status _ _ _ _ _ H_in) => H_or {H_in}.
    move: H_or => [H_ex H_ins'].
    move: H_ex => [q'' [H_eq' H_in]].
    move: H_in.
    rewrite /put_mbox /= /t_put_mbox /=.
    set t5_before := mk_nd_bfs _ _ _ _ _.
    move => H_in.
    case: H_in' => H_in'.
      rewrite -H_in'.
      have H_p: P t5_before t_before.
        apply IH; first by right.
        by left.
      exact: (broadcast_dual_in_trd T1 _ q5 _ _ _ q'').
    case (in_enqueue_status _ _ _ _ _ H_in') => H_or {H_in'}.
      move: H_or => [H_ex H_ins].
      move: H_ex => [q''' [H_eq H_in']].
      move: H_in'.
      rewrite /put_mbox /= /t_put_mbox /=.
      set t'_before := mk_nd_bfs _ _ _ _ _.
      move => H_in'.
      have H_p: P t5_before t'_before by apply IH; right.
      exact: (broadcast_dual_in_fth T1 i5 q5 I5 L5 _ _ q'' q''').
    move: H_or => [H_in' H_ins].
    have H_p: P t5_before t' by apply IH; right.
    exact: (broadcast_dual_in_fft T1 i5 q5 I5 L5 _ _ q'').
  move: H_or => [H_in H_ins].
  case: H_in' => H_in'.
    rewrite -H_in'.
    have H_p: P t5 t_before.
      apply IH; first by right.
      by left.
    exact: (broadcast_dual_in_sth T1 _ q5).
  case (in_enqueue_status _ _ _ _ _ H_in') => H_or {H_in'}.
    move: H_or => [H_ex H_ins'].
    move: H_ex => [q'' [H_eq H_in']].
    move: H_in'.
    rewrite /put_mbox /= /t_put_mbox /=.
    set t'_before := mk_nd_bfs _ _ _ _ _.
    move => H_in'.
    have H_p: P t5 t'_before by apply IH; right.
    exact: (broadcast_dual_in_svt T1 i5 q5 I5 L5 _ _ q'').
  move: H_or => [H_in' H_ins'].
  by apply: IH; by right.
- (* partial *)
  inversion H; subst.
  * (* new *)
    move: H_ok IH H H_red.
    clear H_ok.
    set t0_before := mk_nd_bfs _ _ _ _ _.
    set t1_before := mk_nd_bfs _ _ _ _ _.
    set t0_after := mk_nd_bfs _ _ _ _ _.
    set t1_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red.
    move => t5 t' H_in H_in'.
    case: H_in => H_in.
      rewrite -H_in.
      case: H_in' => H_in'.
        rewrite -H_in'.
        have H_p: P t0_before t0_before by apply IH; left.
        exact: (new_new_dual_fst T'0 _ q5 _ _ _ _ q' I' b' L' _ lv5).
      case: H_in' => H_in'.
        rewrite -H_in'.
        have H_p: P t0_before t1_before.
          apply IH; first by left.
          by right; left.
        exact: (new_new_dual_snd T'0 _ q5).
      have H_p: P t0_before t'.
        apply IH; first by left.
        by right; right.
      exact: (new_new_dual_in_fst T'0 _ q5 _ _ _ _ q' I' b' L' _ lv5).
    case: H_in => H_in.
      rewrite -H_in.
      case: H_in' => H_in'.
        rewrite -H_in'.
        have H_p: P t1_before t0_before.
          apply IH; first by right; left.
          by left.
        exact: (new_new_dual_trd T'0 _ q5).
      case: H_in' => H_in'.
        rewrite -H_in'.
        have H_p: P t1_before t1_before by apply IH; right; left.
        exact: (new_new_dual_fth T'0 _ q5 I5 b5 L5 _ _ _ _ _ q'').
      have H_p: P t1_before t'.
        apply IH; first by right; left.
        by right; right.
      exact: (new_new_dual_in_snd T'0 _ q5 I5 b5 L5 _ _ _ _ _ q'').
    case: H_in' => H_in'.
      rewrite -H_in'.
      have H_p: P t5 t0_before.
        apply IH; first by right; right.
        by left.
      exact: (new_new_dual_in_trd T'0 _ q5 _ _ _ _ q' I' b' L' _ lv5).
    case: H_in' => H_in'; last by apply IH; right; right.
    rewrite -H_in'.
    have H_p: P t5 t1_before.
      apply IH; first by right; right.
      by right; left.
    exact: (new_new_dual_in_fth T'0 _ q5 I5 b5 L5 _ _ _ _ _ q'').
  * (* new_root *)
    move: H_ok IH H H_red.
    clear H_ok.
    set t0_before := mk_nd_bfs _ _ _ _ _.
    set t1_before := mk_nd_bfs _ _ _ _ _.
    set t0_after := mk_nd_bfs _ _ _ _ _.
    set t1_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red.
    move => t5 t' H_in H_in'.
    case: H_in => H_in.
      rewrite -H_in.
      case: H_in' => H_in'.
        rewrite -H_in'.
        have H_p: P t0_before t0_before by apply IH; left.
        exact: (new_new_root_dual_fst T'0 q5 _ _ _ _ q' I' b' L').
      case: H_in' => H_in'.
        rewrite -H_in'.
        have H_p: P t0_before t1_before.
          apply IH; first by left.
          by right; left.
        exact: (new_new_root_dual_snd T'0 q5).
      have H_p: P t0_before t'.
        apply IH; first by left.
        by right; right.
      exact: (new_new_root_dual_in_fst T'0 q5 _ _ _ _ q' I' b' L').
    case: H_in => H_in.
      rewrite -H_in.
      case: H_in' => H_in'.
        rewrite -H_in'.
        have H_p: P t1_before t0_before.
          apply IH; first by right; left.
          by left.
        exact: (new_new_root_dual_trd T'0 q5).
      case: H_in' => H_in'.
        rewrite -H_in'.
        have H_p: P t1_before t1_before by apply IH; right; left.
        exact: (new_new_root_dual_fth T'0 q5 I5 b5 L5 _ _ _ _ _ q'').
      have H_p: P t1_before t'.
        apply IH; first by right; left.
        by right; right.
      exact: (new_new_root_dual_in_snd T'0 q5 I5 b5 L5 _ _ _ _ _ q'').
    case: H_in' => H_in'.
      rewrite -H_in'.
      have H_p: P t5 t0_before.
        apply IH; first by right; right.
        by left.
      exact: (new_new_root_dual_in_trd T'0 q5 _ _ _ _ q' I' b' L').
    case: H_in' => H_in'; last by apply IH; right; right.
    rewrite -H_in'.
    have H_p: P t5 t1_before.
      apply IH; first by right; right.
      by right; left.
    exact: (new_new_root_dual_in_fth T'0 q5 I5 b5 L5 _ _ _ _ _ q'').
  (* new *)
  * move: H_ok IH H H_red.
    clear H_ok.
    set t_before := mk_nd_bfs _ _ _ _ _.
    set t_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red.
    move => t5 t' H_in H_in'.
    case: H_in => H_in.
      rewrite -H_in.
      case: H_in' => H_in'.
        rewrite -H_in'.
        have H_p: P t_before t_before by apply IH; left.
        exact: (new_node_dual T'0 _ q5).
      have H_p: P t_before t'.
        apply IH; first by left.
        by right.
      exact: (new_node_dual_in_fst T'0 _ q5).
    case: H_in' => H_in'.
      rewrite -H_in'.
      have H_p: P t5 t_before.
        apply IH; first by right.
        by left.
      exact: (new_node_dual_in_snd T'0 _ q5).
    apply IH; first by right.
    by right.
  * (* fail_eq *)
    move: H_ok IH H H_red.
    clear H_ok.
    set t_before := mk_nd_bfs _ _ _ _ _.
    set t_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red t5 t' H_in H_in'.
    case: H_in => H_in.
      rewrite -H_in.
      case: H_in' => H_in'.
        rewrite -H_in'.     
        have H_p: P t_before t_before by apply IH; left.
        exact: (fail_eq_node_dual T'0 _ q5).
      have H_p: P t_before t'.
        apply IH; first by left.
        by right.
      exact: (fail_eq_node_dual_in_fst T'0 _ q5).
    case: H_in' => H_in'.
      rewrite -H_in'.
      have H_p: P t5 t_before.
        apply IH; first by right.
        by left.
      exact: (fail_eq_node_dual_in_snd T'0 _ q5).
    apply IH; first by right.
    by right.
  * (* fail_neq *)
    move: H_ok IH H H_red.
    clear H_ok.
    set t_before := mk_nd_bfs _ _ _ _ _.
    set t_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red t5 t' H_in H_in'.
    case: H_in => H_in.
      rewrite -H_in.
      case: H_in' => H_in'.
        rewrite -H_in'.     
        have H_p: P t_before t_before by apply IH; left.
        exact: (fail_neq_node_dual T'0 _ q5 _ b5).
      have H_p: P t_before t'.
        apply IH; first by left.
        by right.
      exact: (fail_neq_node_dual_in_fst T'0 _ q5 _ b5).
    case: H_in' => H_in'.
      rewrite -H_in'.
      have H_p: P t5 t_before.
        apply IH; first by right.
        by left.
      exact: (fail_neq_node_dual_in_snd T'0 _ q5 _ b5).
    apply IH; first by right.
    by right.
  * (* fail_root *)
    move: H_ok IH H H_red.
    clear H_ok.
    set t_before := mk_nd_bfs _ _ _ _ _.
    set t_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red t5 t' H_in H_in'.
    case: H_in => H_in.
      rewrite -H_in.
      case: H_in' => H_in'.
        rewrite -H_in'.     
        have H_p: P t_before t_before by apply IH; left.
        exact: (fail_root_node_dual T'0 q5).
      have H_p: P t_before t'.
        apply IH; first by left.
        by right.
      exact: (fail_root_node_dual_in_fst T'0 q5).
    case: H_in' => H_in'.
      rewrite -H_in'.
      have H_p: P t5 t_before.
        apply IH; first by right.
        by left.
      exact: (fail_root_node_dual_in_snd T'0 q5).
    apply IH; first by right.
    by right.
  * (* status_eq *)
    move: H_ok IH H H_red.
    clear H_ok.
    set t_before := mk_nd_bfs _ _ _ _ _.
    set t_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red t5 t' H_in H_in'.
    case: H_in => H_in.
      rewrite -H_in.
      case: H_in' => H_in'.
        rewrite -H_in'.     
        have H_p: P t_before t_before by apply IH; left.
        exact: (status_eq_node_dual T'0 _ q5).
      have H_p: P t_before t'.
        apply IH; first by left.
        by right.
      exact: (status_eq_node_dual_in_fst T'0 _ q5).
    case: H_in' => H_in'.
      rewrite -H_in'.
      have H_p: P t5 t_before.
        apply IH; first by right.
        by left.
      exact: (status_eq_node_dual_in_snd T'0 _ q5).
    apply IH; first by right.
    by right.
  * (* status_eq_bot *)
    move: H_ok IH H H_red.
    clear H_ok.
    set t_before := mk_nd_bfs _ _ _ _ _.
    set t_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red t5 t' H_in H_in'.
    case: H_in => H_in.
      rewrite -H_in.
      case: H_in' => H_in'.
        rewrite -H_in'.     
        have H_p: P t_before t_before by apply IH; left.
        exact: (status_eq_bot_node_dual T'0 _ q5).
      have H_p: P t_before t'.
        apply IH; first by left.
        by right.
      exact: (status_eq_bot_node_dual_in_fst T'0 _ q5).
    case: H_in' => H_in'.
      rewrite -H_in'.
      have H_p: P t5 t_before.
        apply IH; first by right.
        by left.
      exact: (status_eq_bot_node_dual_in_snd T'0 _ q5).
    apply IH; first by right.
    by right.
  * (* status_neq *)
    move: H_ok IH H H_red.
    clear H_ok.
    set t_before := mk_nd_bfs _ _ _ _ _.
    set t_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red t5 t' H_in H_in'.
    case: H_in => H_in.
      rewrite -H_in.
      case: H_in' => H_in'.
        rewrite -H_in'.     
        have H_p: P t_before t_before by apply IH; left.
        exact: (status_neq_node_dual T'0 _ q5 _ b5).
      have H_p: P t_before t'.
        apply IH; first by left.
        by right.
      exact: (status_neq_node_dual_in_fst T'0 _ q5 _ b5).
    case: H_in' => H_in'.
      rewrite -H_in'.
      have H_p: P t5 t_before.
        apply IH; first by right.
        by left.
      exact: (status_neq_node_dual_in_snd T'0 _ q5 _ b5).
    apply IH; first by right.
    by right.
  * (* status_neq_bot *)
    move: H_ok IH H H_red.
    clear H_ok.
    set t_before := mk_nd_bfs _ _ _ _ _.
    set t_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red t5 t' H_in H_in'.
    case: H_in => H_in.
      rewrite -H_in.
      case: H_in' => H_in'.
        rewrite -H_in'.     
        have H_p: P t_before t_before by apply IH; left.
        exact: (status_neq_bot_node_dual T'0 _ q5 _ b5).
      have H_p: P t_before t'.
        apply IH; first by left.
        by right.
      exact: (status_neq_bot_node_dual_in_fst T'0 _ q5 _ b5).
    case: H_in' => H_in'.
      rewrite -H_in'.
      have H_p: P t5 t_before.
        apply IH; first by right.
        by left.
      exact: (status_neq_bot_node_dual_in_snd T'0 _ q5 _ b5).
    apply IH; first by right.
    by right.
  * (* status_root *)
    move: H_ok IH H H_red.
    clear H_ok.
    set t_before := mk_nd_bfs _ _ _ _ _.
    set t_after := mk_nd_bfs _ _ _ _ _.
    rewrite /=.
    move => H_ok IH H H_red t5 t' H_in H_in'.
    case: H_in => H_in.
      rewrite -H_in.
      case: H_in' => H_in'.
        rewrite -H_in'.     
        have H_p: P t_before t_before by apply IH; left.
        exact: (status_root_node_dual T'0 q5 _ _ _ _ j lvo5).
      have H_p: P t_before t'.
        apply IH; first by left.
        by right.
      exact: (status_root_node_dual_in_fst T'0 q5 _ _ _ _ j lvo5).
    case: H_in' => H_in'.
      rewrite -H_in'.
      have H_p: P t5 t_before.
        apply IH; first by right.
        by left.
      exact: (status_root_node_dual_in_snd T'0 q5 _ _ _ _ j lvo5).
    apply IH; first by right.
    by right.
Qed.

End DualNodeInvBfs.

Lemma bfs_net_ok_notin_adj_not_sent_status : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 t' : t), In t5 T5 -> In t' T5 ->
  ~ ISet.In (bfs_ident t') (bfs_adj t5) ->
  forall (lvo5 : lvo), ~ In_queue (msg_status (bfs_ident t5) lvo5) (bfs_mbox t').
Proof.
move => T5 H_ok t5 t' H_in H_in'.
pose P_curr (t5 t' : t) := ~ ISet.In (bfs_ident t') (bfs_adj t5) ->
   forall lvo5 : lvo, ~ In_queue (msg_status (bfs_ident t5) lvo5) (bfs_mbox t').
rewrite -/(P_curr _ _).
apply (P_inv_dual_bfs T5); rewrite /P_curr //= {H_ok T5 H_in H_in' t5 t' P_curr}.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins lvo5.
  have H_inn: In t_before (t_before :: T5) by left.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_ins': ~ ISet.In i5 I5 by exact: (not_adjacent_self_bfs _ H_ok _ H_inn).
  have H_bef' := H_bef H_ins' lvo5.
  move => H_q.  
  contradict H_bef'.
  move: H_deq H_q.
  exact: dequeued_in_after_in_before.
- (* new *)
  by auto with set.
- (* new *)
  by eauto with queue_in.
- (* fail_eq *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins lvo5.
  have H_inn: In t_before (t_before :: T5) by left.
  apply first_firstin in H_fst.  
  apply dequeue_dequeued in H_deq.
  have H_ins': ~ ISet.In i5 I5 by exact: (not_adjacent_self_bfs _ H_ok _ H_inn).
  have H_bef' := H_bef H_ins' lvo5.
  move => H_q.  
  contradict H_bef'.
  move: H_deq H_q.
  exact: dequeued_in_after_in_before.
- (* fail_eq *)
  move => T5 i5 q5 I5 b5 L5 q' j t' H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins lvo5.
  apply first_firstin in H_fst.  
  apply dequeue_dequeued in H_deq.
  apply: H_bef.
  move => H_ins'.
  contradict H_ins.
  have H_neq': j <> bfs_ident t'.
    move => H_eq.
    have H_inn: In t_before (t_before :: T5) by left.
    have H_inn': In t' (t_before :: T5) by right.
    have H_inv := in_network_no_id_fails_inv_bfs _ H_ok _ _ H_inn' H_inn.
    rewrite /= -H_eq in H_inv.
    by apply firstin_in_queue in H_fst.
  exact: ISetFacts.remove_2.
- (* fail_eq *)
  by eauto with queue_in.
- (* fail_neq *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins lvo5.
  have H_inn: In t_before (t_before :: T5) by left.
  apply first_firstin in H_fst.  
  apply dequeue_dequeued in H_deq.
  have H_ins': ~ ISet.In i5 I5 by exact: (not_adjacent_self_bfs _ H_ok _ H_inn).  
  have H_bef' := H_bef H_ins' lvo5.
  move => H_q.  
  contradict H_bef'.
  move: H_deq H_q.
  exact: dequeued_in_after_in_before.
- (* fail_neq *)
  move => T5 i5 q5 I5 b5 L5 q' j t' H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins lvo5.
  apply first_firstin in H_fst.  
  apply dequeue_dequeued in H_deq.
  apply: H_bef.
  move => H_ins'.
  contradict H_ins.
  have H_neq': j <> bfs_ident t'.
    move => H_eq.
    have H_inn: In t_before (t_before :: T5) by left.
    have H_inn': In t' (t_before :: T5) by right.
    have H_inv := in_network_no_id_fails_inv_bfs _ H_ok _ _ H_inn' H_inn.
    rewrite /= -H_eq in H_inv.
    by apply firstin_in_queue in H_fst.
  exact: ISetFacts.remove_2.
- (* fail_neq *)
  by eauto with queue_in.
- (* root_fail *)
  move => T5 q5 I5 b5 L5 q' j H_fst H_deq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins lvo5.
  have H_inn: In t_before (t_before :: T5) by left.
  apply first_firstin in H_fst.  
  apply dequeue_dequeued in H_deq.
  have H_ins': ~ ISet.In 0 I5 by exact: (not_adjacent_self_bfs _ H_ok _ H_inn).  
  have H_bef' := H_bef H_ins' lvo5.
  move => H_q.  
  contradict H_bef'.
  move: H_deq H_q.
  exact: dequeued_in_after_in_before.  
- (* fail_root *)
  move => T5 q5 I5 b5 L5 q' j t' H_fst H_deq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins lvo5.
  apply first_firstin in H_fst.  
  apply dequeue_dequeued in H_deq.
  apply: H_bef.
  move => H_ins'.
  contradict H_ins.
  have H_neq': j <> bfs_ident t'.
    move => H_eq.
    have H_inn: In t_before (t_before :: T5) by left.
    have H_inn': In t' (t_before :: T5) by right.
    have H_inv := in_network_no_id_fails_inv_bfs _ H_ok _ _ H_inn' H_inn.
    rewrite /= -H_eq in H_inv.
    by apply firstin_in_queue in H_fst.
  exact: ISetFacts.remove_2.
- (* fail_root *)
  by eauto with queue_in.
- (* status_eq *)
  by eauto with queue_in.
- (* status_eq *)
  by eauto with queue_in.
- (* status_bot_eq *)
  by eauto with queue_in.
- (* status_bot_eq *)
  by eauto with queue_in.
- (* status_bot_neq *)
  by eauto with queue_in.
- (* status_bot_neq *)
  by eauto with queue_in.
- (* status_bot_neq *)
  by eauto with queue_in.
- (* status_bot_neq *)
  by eauto with queue_in.
- (* status_root *)
  by eauto with queue_in.
- (* status_root *)
  by eauto with queue_in.
- (* init *)
  move => T5 T' i5 H_ok H_fresh H_ins lvo5 {T5 H_ok H_fresh H_ins}.
  elim: T' i5 lvo5 => [|t5 T5 IH] i5 lvo5 //.
  move => H_q.
  rewrite /= in H_q.
  case: H_q => H_q //.
  contradict H_q.
  exact: IH.  
- (* init *)
  move => T5 T' i5 t' H_ok H_fresh H_in H_ins lvo5 H_q.
  have H_inn: In t' (T5 ++ T') by apply in_or_app; left.  
  case (in_queue_status_then_new _ H_ok _ H_inn _ _ H_q) => H_or; contradict H_or.
    exact: (fresh_new_not_in_queue_bfs _ H_ok).
  exact: (fresh_not_in_adj_bfs _ H_ok).
- (* init *)
  move => T5 T' i5 t5 H_ok H_fresh H_in H_ins lvo5 {T5 H_ok H_fresh H_ins H_in}.
  elim: T' i5 lvo5 => [|t' T5 IH] i5 lvo5 //.
  move => H_q.
  rewrite /= in H_q.
  case: H_q => H_q //.
  contradict H_q.
  exact: IH. 
- (* init *)
  move => T5 T' i5 t' q5 H_ok H_fresh H_eq.
  set t'_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_ins lvo5.
  rewrite H_eq /=.
  move => H_or.
  case: H_or => H_or //.
  have H_inn: In t'_before (T5 ++ T') by apply in_or_app; right.  
  case (in_queue_status_then_new _ H_ok _ H_inn _ _ H_or) => H_or'; contradict H_or'.
    exact: (fresh_new_not_in_queue_bfs _ H_ok).
  exact: (fresh_not_in_adj_bfs _ H_ok).
- (* init *)
  move => T5 T' i5 q5 t5 t' H_ok H_fresh H_eq.
  set t'_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_in' H_bef H_ins lvo5.
  rewrite H_eq /=.  
  move => H_or.
  case: H_or => H_or //.
  contradict H_or.
  exact: H_bef.
- (* init *)
  move => T5 T' i5 q5 t5 H_ok H_fresh H_eq.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_ins lvo5 {T5 q5 H_ok H_fresh H_eq H_in H_ins i5 t5_before}.
  elim: T' t5 lvo5 => [|t' T5 IH] t5 lvo5 //.
  move => H_q.
  rewrite /= in H_q.
  case: H_q => H_q //.
  contradict H_q.
  exact: IH.    
- (* init *)
  move => T5 T' i5 q5 q' t5 t' H_ok H_fresh H_q H_q'.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  set t'_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_in' H_bef H_ins lvo5.
  rewrite H_q' /=.
  move => H_or.
  case: H_or => H_or //.  
  contradict H_or.
  exact: H_bef.
- (* fail *)
  move => T5 i5 q' I5 b5 L5 t5 t6 q5 q6.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  set t6_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_q H_q' H_in H_in' H_bef H_ins lvo5.
  rewrite H_q' /=.
  move => H_or.
  case: H_or => H_or //.  
  contradict H_or.
  exact: H_bef.
- (* fail *)
  move => T5 i5 q' I5 b5 L5 t5 t6 q6.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t6_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_q H_in H_in' H_bef H_ins lvo5.
  rewrite H_q /=.
  move => H_or.
  case: H_or => H_or //.  
  contradict H_or.
  exact: H_bef.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins lvo5.
  have H_inn: In t0_before (t0_before :: t1_before :: T5) by left.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_ins': ~ ISet.In i5 I5 by exact: (not_adjacent_self_bfs _ H_ok _ H_inn).
  have H_bef' := H_bef H_ins' lvo5.
  move => H_q.  
  contradict H_bef'.
  move: H_deq H_q.
  exact: dequeued_in_after_in_before.
- (* new *)
  by auto with set.
- (* new *)
  by eauto with queue_in.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins lvo5 H_or.
  case: H_or => H_or; last by contradict H_or; apply: H_bef.
  injection H_or => H_eq_lv H_eq_i.
  apply bfs_net_ok_nodup in H_ok.
  inversion H_ok.
  contradict H1.
  apply InA_alt.
  exists t1_before.
  split => //.
  by left. 
- (* new *)
  by auto with set.    
- (* new *) 
  by eauto with queue_in.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 t' H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins lvo5 H_or.
  case: H_or => H_or; last by contradict H_or; apply: H_bef.
  injection H_or => H_eq_lv H_eq_i.
  apply bfs_net_ok_nodup in H_ok.
  inversion H_ok.
  contradict H1.
  apply InA_alt.
  exists t'.
  split => //.
  by right.
- (* new_ex *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 H_fst H_deq H_lv H_neq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins lvo5.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_inn: In t_before (t_before :: T5) by left.
  have H_ins': ~ ISet.In i5 I5 by exact: (not_adjacent_self_bfs _ H_ok _ H_inn).
  have H_bef' := H_bef H_ins' lvo5.
  move => H_q.  
  contradict H_bef'.
  move: H_deq H_q.
  exact: dequeued_in_after_in_before.
- (* new_ex *)
  by auto with set.
- (* new_ex *)
  by eauto with queue_in.
- (* new_root *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins lvo5.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_inn: In t0_before (t0_before :: t1_before :: T5) by left.
  have H_ins': ~ ISet.In 0 I5 by exact: (not_adjacent_self_bfs _ H_ok _ H_inn).
  have H_bef' := H_bef H_ins' lvo5.
  move => H_q.  
  contradict H_bef'.
  move: H_deq H_q.
  exact: dequeued_in_after_in_before.
- (* new_root *)
  by auto with set.
- (* new_root *)
  by eauto with queue_in.
- (* new_root *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins lvo5 H_or.
  case: H_or => H_or; last by contradict H_or; apply: H_bef.
  injection H_or => H_eq_lv H_eq_i.
  apply bfs_net_ok_nodup in H_ok.
  inversion H_ok.
  contradict H1.
  apply InA_alt.
  exists t1_before.
  split => //.
  by left.
- (* new_root *)
  by auto with set.
- (* new_root *)
  by eauto with queue_in.
- (* new_root *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' t5 H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins lvo5 H_or.
  case: H_or => H_or; last by contradict H_or; apply: H_bef.
  injection H_or => H_eq_lv H_eq_i.
  apply bfs_net_ok_nodup in H_ok.
  inversion H_ok.
  contradict H1.
  apply InA_alt.
  exists t5.
  split => //.
  by right.
- (* new_root_ex *)
  move => T5 q5 I5 b5 L5 q' j H_fst H_deq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins lvo5.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_inn: In t_before (t_before :: T5) by left.
  have H_ins': ~ ISet.In 0 I5 by exact: (not_adjacent_self_bfs _ H_ok _ H_inn).
  have H_bef' := H_bef H_ins' lvo5.
  move => H_q.  
  contradict H_bef'.
  move: H_deq H_q.
  exact: dequeued_in_after_in_before.
- (* new_root_ex *)
  by auto with set.
- (* new_root_ex *)
  by eauto with queue_in.
- (* broadcast *)
  move => T5 i5 q5 I5 L5 t5 t' q' q'' H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  set t'_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_q H_q' H_in H_in' H_ins H_ins' H_bef H_ins'' lvo5 H_or.
  rewrite H_q' /= in H_or.
  case: H_or => H_or; last by contradict H_or; apply: H_bef.
  injection H_or => H_eq_lv H_eq_i.
  apply bfs_net_ok_nodup in H_ok.
  inversion H_ok.
  contradict H1.
  apply InA_alt.
  exists t5_before.
  by split.
- (* broadcast *)
  move => T5 i5 q5 I5 L5 t5 t' q' H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_q H_in H_in' H_ins H_ins' H_bef H_ins'' lvo5 H_or.
  rewrite H_q /= in H_or.
  case: H_or => H_or; last by contradict H_or; apply: H_bef.
  injection H_or => H_eq_lv H_eq_i.
  apply bfs_net_ok_nodup in H_ok.
  inversion H_ok.
  contradict H1.
  apply InA_alt.
  exists t'.
  by split.
Qed.

Lemma bfs_net_ok_notin_adj_find_none : forall (T5 : T), bfs_net_ok T5 -> 
  forall (t5 t' : t), In t5 T5 -> In t' T5 ->
  ~ ISet.In (bfs_ident t') (bfs_adj t5) ->
  IMap.find (bfs_ident t5) (bfs_levels t') = None.
Proof.
move => T5 H_ok t5 t' H_in H_in'.
pose P_curr (t5 t' : t) := ~ ISet.In (bfs_ident t') (bfs_adj t5) ->
   IMap.find (elt:=lv) (bfs_ident t5) (bfs_levels t') = None.
rewrite -/(P_curr _ _).
apply (P_inv_dual_bfs T5); rewrite /P_curr // {H_ok T5 H_in H_in' t5 t' P_curr}.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins.
  rewrite /= in H_ins.
  apply: H_bef.
  move => H_ins'.
  contradict H_ins.
  exact: ISetFacts.add_2.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 q' j t' H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins.
  apply: H_bef.
  move => H_ins'.
  contradict H_ins.
  exact: ISetFacts.add_2.
- (* fail_eq *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins.
  rewrite /=.
  rewrite /= in H_bef, H_ins.
  case (eq_i j i5) => H_eq; first by rewrite -H_eq IMapFacts.remove_eq_o //.
  rewrite IMapFacts.remove_neq_o => //.
  apply: H_bef. 
  move => H_ins'.
  contradict H_ins.
  exact: ISetFacts.remove_2.
- (* fail_eq *)
  move => T5 i5 q5 I5 b5 L5 q' j t' H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins.
  have H_neq': j <> bfs_ident t'.
    move => H_eq.
    rewrite H_eq in H_fst.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    contradict H_fst.
    have H_in': In t_before (t_before :: T5) by left.
    move: H_in'.  
    apply: (in_network_no_id_fails_inv_bfs _ H_ok) => //.
    by right.
  apply: H_bef.
  move => H_ins'.
  contradict H_ins.
  rewrite /=.
  exact: ISetFacts.remove_2.
- (* fail_eq *)
  move => T5 i5 q5 I5 b5 L5 q' j t' H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins.
  have H_neq': j <> bfs_ident t'.
    move => H_eq.
    rewrite H_eq in H_fst.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    contradict H_fst.
    have H_in': In t_before (t_before :: T5) by left.
    move: H_in'.  
    apply: (in_network_no_id_fails_inv_bfs _ H_ok) => //.
    by right.
  rewrite /=.
  rewrite IMapFacts.remove_neq_o //.
  apply: H_bef.
  move => H_ins'.
  by contradict H_ins.
- (* fail_neq *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins.
  rewrite /=.
  have H_neq': j <> i5.
    move => H_eq.
    rewrite H_eq in H_fst.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    contradict H_fst.
    have H_in': In t_before (t_before :: T5) by left.
    have H_in := H_in'.
    have ->: i5 = bfs_ident t_before by [].
    move: H_in'.
    exact: (in_network_no_id_fails_inv_bfs _ H_ok).
  rewrite IMapFacts.remove_neq_o //.
  apply: H_bef.
  move => H_ins'.
  contradict H_ins.
  rewrite /=.
  exact: ISetFacts.remove_2.
- (* fail_neq *)
  move => T5 i5 q5 I5 b5 L5 q' j t' H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins.
  rewrite /=.
  apply: H_bef.
  rewrite /=.
  rewrite /= in H_ins.
  have H_neq': j <> bfs_ident t'.
    move => H_eq.
    rewrite H_eq in H_fst.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    contradict H_fst.
    have H_in': In t_before (t_before :: T5) by left.
    move: H_in'.
    apply: (in_network_no_id_fails_inv_bfs _ H_ok).
    by right.
  move => H_ins'.
  contradict H_ins.
  rewrite /=.
  exact: ISetFacts.remove_2.
- (* fail_neq *)
  move => T5 i5 q5 I5 b5 L5 q' j t5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins.
  rewrite /=.
  have H_neq': j <> bfs_ident t5.
    move => H_eq.
    rewrite H_eq in H_fst.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    contradict H_fst.
    have H_in': In t_before (t_before :: T5) by left.
    move: H_in'.
    apply: (in_network_no_id_fails_inv_bfs _ H_ok).
    by right.
  rewrite IMapFacts.remove_neq_o //.
  exact: H_bef.
- (* fail_root *)
  move => T5 q5 I5 b5 L5 q' j H_fst H_deq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins.
  apply: H_bef.
  have H_neq': j <> 0.
    move => H_eq.
    rewrite H_eq in H_fst.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    contradict H_fst.
    have H_in': In t_before (t_before :: T5) by left.
    have H_in := H_in'.
    have ->: 0 = bfs_ident t_before by [].
    move: H_in'.
    exact: (in_network_no_id_fails_inv_bfs _ H_ok).
  move => H_ins'.
  contradict H_ins.
  rewrite /=.
  exact: ISetFacts.remove_2.
- (* fail_root *)
  move => T5 q5 I5 b5 L5 q' j t' H_fst H_deq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins.
  apply: H_bef.
  rewrite /=.
  rewrite /= in H_ins.
  have H_neq': j <> bfs_ident t'.
    move => H_eq.
    rewrite H_eq in H_fst.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    contradict H_fst.
    have H_in': In t_before (t_before :: T5) by left.
    move: H_in'.
    apply: (in_network_no_id_fails_inv_bfs _ H_ok).
    by right.
  move => H_ins'.
  contradict H_ins.
  exact: ISetFacts.remove_2.
- (* status_eq *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  have H_neq': j <> i5.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    have H_in: In t_before (t_before :: T5) by left.
    have H_q := bfs_net_ok_notin_adj_not_sent_status _ H_ok _ _ H_in H_in H_ins (Some lv5).
    move => H_eq.
    by rewrite H_eq in H_fst.
  rewrite IMapFacts.add_neq_o //.
  exact: H_bef.
- (* status_eq *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 t' H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  have H_neq': j <> bfs_ident t'.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    have H_in': In t_before (t_before :: T5) by left.
    have H_inn: In t' (t_before :: T5) by right.
    have H_q := bfs_net_ok_notin_adj_not_sent_status _ H_ok _ _ H_inn H_in' H_ins (Some lv5).
    move => H_eq.
    by rewrite H_eq in H_fst.
  rewrite IMapFacts.add_neq_o //.
  exact: H_bef.
- (* status_bot_eq *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  have H_neq': j <> i5.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    have H_in: In t_before (t_before :: T5) by left.
    have H_q := bfs_net_ok_notin_adj_not_sent_status _ H_ok _ _ H_in H_in H_ins None.
    move => H_eq.
    by rewrite H_eq in H_fst.    
  rewrite IMapFacts.remove_neq_o //.
  exact: H_bef.
- (* status_bot_eq *)
  move => T5 i5 q5 I5 b5 L5 q' j t5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  have H_neq': j <> bfs_ident t5.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    have H_in': In t_before (t_before :: T5) by left.
    have H_inn: In t5 (t_before :: T5) by right.
    have H_q := bfs_net_ok_notin_adj_not_sent_status _ H_ok _ _ H_inn H_in' H_ins None. 
    move => H_eq.
    by rewrite H_eq in H_fst.    
  rewrite IMapFacts.remove_neq_o //.
  exact: H_bef.
- (* status_neq *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  have H_neq': j <> i5.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    have H_in: In t_before (t_before :: T5) by left.
    have H_q := bfs_net_ok_notin_adj_not_sent_status _ H_ok _ _ H_in H_in H_ins (Some lv5).
    move => H_eq.
    by rewrite H_eq in H_fst.
  rewrite IMapFacts.add_neq_o //.
  exact: H_bef.
- (* status_neq *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 t5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  have H_neq': j <> bfs_ident t5.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    have H_in': In t_before (t_before :: T5) by left.
    have H_inn: In t5 (t_before :: T5) by right.
    have H_q := bfs_net_ok_notin_adj_not_sent_status _ H_ok _ _ H_inn H_in' H_ins (Some lv5).
    move => H_eq.
    by rewrite H_eq in H_fst.
  rewrite IMapFacts.add_neq_o //.
  exact: H_bef.
- (* status_bot_neq *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  have H_neq': j <> i5.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    have H_in: In t_before (t_before :: T5) by left.
    have H_q := bfs_net_ok_notin_adj_not_sent_status _ H_ok _ _ H_in H_in H_ins None.
    move => H_eq.
    by rewrite H_eq in H_fst.
  rewrite IMapFacts.remove_neq_o //.
  exact: H_bef.
- (* status_bot_neq *)
  move => T5 i5 q5 I5 b5 L5 q' j t5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  have H_neq': j <> bfs_ident t5.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    have H_in': In t_before (t_before :: T5) by left.
    have H_inn: In t5 (t_before :: T5) by right.
    have H_q := bfs_net_ok_notin_adj_not_sent_status _ H_ok _ _ H_inn H_in' H_ins None.
    move => H_eq.
    by rewrite H_eq in H_fst.
  rewrite IMapFacts.remove_neq_o //.
  exact: H_bef.
- (* init *)
  move => T5 T' i5 t' H_ok H_fresh H_in /=.
  move => H_ins.
  have H_inn: In t' (T5 ++ T') by apply in_or_app; left.
  have H_ins': ~ ISet.In i5 (bfs_adj t').
    move: H_inn.
    exact: fresh_not_in_adj_bfs.
  exact: bfs_net_ok_notins_levels_bot _ H_ok _ H_inn _ H_ins'.
- (* init *)
  move => T5 T' i5 t' q5 H_ok H_fresh H_q.
  set t'_before := mk_nd_bfs _ _ _ _ _.
  rewrite /=.
  move => H_in H_ins.
  have H_inn: In t'_before (T5 ++ T') by apply in_or_app; right.
  have H_ins': ~ ISet.In i5 (bfs_adj t').
    move: H_inn.
    exact: fresh_not_in_adj_bfs.
  exact: bfs_net_ok_notins_levels_bot _ H_ok _ H_inn _ H_ins'.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t0_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  apply: H_bef.
  rewrite /=.
  move => H_ins'.
  contradict H_ins.
  exact: ISetFacts.add_2.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t1_after := mk_nd_bfs _ _ _ _ _.
  set t0_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  apply: H_bef.
  rewrite /=.
  move => H_ins'.
  contradict H_ins.
  exact: ISetFacts.add_1.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 t' H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t0_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  apply: H_bef.
  rewrite /=.
  move => H_ins'.
  contradict H_ins.
  exact: ISetFacts.add_2.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 H_fst H_deq H_lv H_neq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  apply: H_bef.
  rewrite /=.
  move => H_ins'.
  contradict H_ins.
  exact: ISetFacts.add_2.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 t' H_fst H_deq H_lv H_neq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  apply: H_bef.
  move => H_ins'.
  contradict H_ins.
  exact: ISetFacts.add_2.
- (* new_root *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t0_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  apply: H_bef.
  move => H_ins'.
  contradict H_ins.
  exact: ISetFacts.add_2.
- (* new_root *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t1_after := mk_nd_bfs _ _ _ _ _.
  set t0_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  contradict H_ins.
  exact: ISetFacts.add_1.
- (* new_root *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' t' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t0_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  apply: H_bef.
  move => H_ins'.
  contradict H_ins.
  exact: ISetFacts.add_2.
- (* new_root *)
  move => T5 q5 I5 b5 L5 q' j H_fst H_deq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  apply: H_bef.
  rewrite /=.
  move => H_ins'.
  contradict H_ins.
  exact: ISetFacts.add_2.
- (* new_root *)
  move => T5 q5 I5 b5 L5 q' j t' H_fst H_deq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  apply: H_bef.
  rewrite /=.
  move => H_ins'.
  contradict H_ins.
  exact: ISetFacts.add_2.
Qed.

Lemma bfs_net_ok_root_have_level : forall (T5 : T), bfs_net_ok T5 -> 
  forall (t5 t' : t), In t5 T5 -> In t' T5 ->
  bfs_ident t5 = 0 ->
  ISet.In (bfs_ident t') (bfs_adj t5) ->
  (count_eq eq_msg (msg_status (bfs_ident t5) (Some 0)) (bfs_mbox t') = 1%nat /\ IMap.find (bfs_ident t5) (bfs_levels t') = None) \/
  (IMap.find (bfs_ident t5) (bfs_levels t') = Some 0 /\ (forall (lvo5 : lvo), ~ In_queue (msg_status (bfs_ident t5) lvo5) (bfs_mbox t'))).
Proof.
move => T5 H_ok t5 t' H_in H_in'.
pose P_curr (t5 t' : t) := bfs_ident t5 = 0 -> ISet.In (bfs_ident t') (bfs_adj t5) ->
  (count_eq eq_msg (msg_status (bfs_ident t5) (Some 0)) (bfs_mbox t') = 1%nat /\ IMap.find (bfs_ident t5) (bfs_levels t') = None) \/
  (IMap.find (bfs_ident t5) (bfs_levels t') = Some 0 /\ (forall (lvo5 : lvo), ~ In_queue (msg_status (bfs_ident t5) lvo5) (bfs_mbox t'))).
rewrite -/(P_curr _ _).
apply (P_inv_dual_bfs T5); rewrite /P_curr // {H_ok T5 H_in H_in' t5 t' P_curr}.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 q' j t5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  rewrite /=.
  move => H_ok H_in H_bef H_eq H_ins.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  apply H_bef in H_eq => //.
  case: H_eq => H_eq.
    move: H_eq => [H_eq H_find].
    left; split => //.
    apply Logic.eq_sym.
    rewrite -H_eq.
    move: H_fst H_deq.
    exact: firstin_dequeue_neq_eq_count_eq.
  right.
  move: H_eq => [H_find H_q].
  split => //.
  move => lvo5 H_q'.
  have H_qq := H_q lvo5.
  case: H_qq.
  move: H_deq H_q'.
  exact: dequeued_in_after_in_before.
- (* fail_eq *)
  move => T5 i5 q5 I5 b5 L5 q' j t5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  rewrite /=.
  move => H_ok H_in H_bef H_eq H_ins.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_or := H_eq.
  apply H_bef in H_or => //.  
  rewrite H_eq in H_or.
  rewrite H_eq.
  have H_inn: In t_before (t_before :: T5) by left.
  have H_inn': In t5 (t_before :: T5) by right.
  case (eq_i j 0) => H_eq'.
    rewrite H_eq'.
    rewrite H_eq' in H_fst.
    apply firstin_in_queue in H_fst.
    contradict H_fst.
    have H_notin := (in_network_no_id_fails_inv_bfs _ H_ok _ _ H_inn' H_inn).
    by rewrite /= H_eq in H_notin.
  rewrite IMapFacts.remove_neq_o => //.
  have IH' := (H_bef H_eq H_ins).
  rewrite /= H_eq in IH'.
  case: IH' => IH'.
    move: IH' => [IH' H_find].
    left; split => //.
    apply Logic.eq_sym.
    rewrite -IH'.
    move: H_fst H_deq.
    exact: firstin_dequeue_neq_eq_count_eq.
  right.
  move: IH' => [H_find H_q].
  split => //.
  move => lvo5 H_q'.
  have H_qq := H_q lvo5.
  case: H_qq.
  move: H_deq H_q'.
  exact: dequeued_in_after_in_before.
- (* fail_neq *)
  move => T5 i5 q5 I5 b5 L5 q' j t5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  rewrite /=.
  move => H_ok H_in H_bef H_eq H_ins.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_or := H_eq.
  apply H_bef in H_or => //.
  rewrite H_eq in H_or.
  rewrite H_eq.
  have H_inn: In t_before (t_before :: T5) by left.
  have H_inn': In t5 (t_before :: T5) by right.
  case (eq_i j 0) => H_eq'.
    rewrite H_eq'.
    rewrite H_eq' in H_fst.
    apply firstin_in_queue in H_fst.
    contradict H_fst.
    have H_notin := (in_network_no_id_fails_inv_bfs _ H_ok _ _ H_inn' H_inn).
    by rewrite /= H_eq in H_notin.
  rewrite IMapFacts.remove_neq_o => //.
  case: H_or => H_or.
    move: H_or => [H_or H_find].
    left; split => //.
    apply Logic.eq_sym.
    rewrite -H_or.
    move: H_fst H_deq.
    exact: firstin_dequeue_neq_eq_count_eq.
  right.
  move: H_or => [H_find H_q].
  split => //.
  move => lvo5 H_q'.
  have H_qq := H_q lvo5.
  case: H_qq.
  move: H_deq H_q'.
  exact: dequeued_in_after_in_before.
- (* fail_root *)
  move => T5 q5 I5 b5 L5 q' j H_fst H_deq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_eq H_ins.
  apply ISetFacts.remove_3 in H_ins.
  have H_or := H_eq.
  apply H_bef in H_or => //.  
  have H_inn: In t_before (t_before :: T5) by left.
  contradict H_ins.
  exact: (not_adjacent_self_bfs _ H_ok _ H_inn).
- (* fail_root *)
  move => T5 q5 I5 b5 L5 q' j t5 H_fst H_deq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_eq H_ins.
  apply ISetFacts.remove_3 in H_ins.
  by apply H_bef in H_ins.
- (* fail_root *)
  move => T5 q5 I5 b5 L5 q' j t5 H_fst H_deq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_eq H_ins.
  apply bfs_net_ok_nodup in H_ok.
  inversion H_ok; subst.
  contradict H1.
  apply InA_alt.
  by exists t5.
- (* status_eq *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 t5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_eq H_ins.
  have H_or := H_eq.
  apply H_bef in H_or => //.  
  rewrite H_eq in H_or.
  rewrite H_eq.
  have H_inn: In t_before (t_before :: T5) by left.
  have H_inn': In t5 (t_before :: T5) by right.
  case (eq_i j 0) => H_eq'.
    rewrite H_eq' in H_fst.
    apply first_firstin in H_fst.
    have H_q := H_fst.
    apply firstin_in_queue in H_q.
    have H_eq'' := bfs_net_ok_root_status_in_queue _ H_ok _ H_inn _ H_q.
    rewrite -H_eq'' /=.
    right; split; first by rewrite IMapFacts.add_eq_o.
    rewrite /= in H_ins.
    injection H_eq'' => H_eq_lv {H_eq''}.
    rewrite H_eq_lv in H_lv, H_fst, H_q.
    move => lvo5 H_q'.
    apply dequeue_dequeued in H_deq.
    have H_q'': In_queue (msg_status 0 lvo5) q5.
      move: H_q'.
      exact: dequeued_in_after_in_before.
    have H_lv_eq := bfs_net_ok_root_status_in_queue _ H_ok _ H_inn _ H_q''.
    rewrite H_lv_eq {H_q'' H_lv_eq} in H_q'.
    case: H_or => H_or.
      rewrite /= in H_or.
      move: H_or => [H_or H_find].
      have H_cnt: count_eq eq_msg (msg_status 0 (Some 0)) q' = 0 by move: H_or H_fst H_deq; exact: firstin_dequeue_less.
      by apply notin_queue_count_eq_0_iff in H_cnt.
    move: H_or => [H_find H_nq].
    contradict H_q.
    exact: H_nq.
  rewrite IMapFacts.add_neq_o => //=.
  case: H_or => H_or.
    move: H_or => [H_or H_find].
    left; split => //.
    apply first_firstin in H_fst.
    apply dequeue_dequeued in H_deq.
    apply Logic.eq_sym.
    rewrite -H_or.
    move: H_fst H_deq.
    apply: firstin_dequeue_neq_eq_count_eq => //.
    by move => H_eq''; injection H_eq'' => H_eq_lv H_eq_i; apply Logic.eq_sym in H_eq_i.
  move: H_or => [H_find H_q].
  right.
  split => //.
  move => lvo5 H_q'.
  apply dequeue_dequeued in H_deq.
  have H_qq: In_queue (msg_status 0 lvo5) q5.
    move: H_deq H_q'.
    exact: dequeued_in_after_in_before.
  contradict H_qq.
  exact: H_q.
- (* status_eq_bot *)
  move => T5 i5 q5 I5 b5 L5 q' j t5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  rewrite /=.
  move => H_ok H_in H_bef H_eq H_ins.
  have H_or := H_eq.
  apply H_bef in H_or => //.  
  rewrite H_eq in H_or.
  rewrite H_eq.
  have H_inn: In t_before (t_before :: T5) by left.
  have H_inn': In t5 (t_before :: T5) by right.
  have H_neq': j <> 0.
    move => H_eq'.
    rewrite H_eq' in H_fst.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    by have H_eq'' := bfs_net_ok_root_status_in_queue _ H_ok _ H_inn _ H_fst.
  rewrite IMapFacts.remove_neq_o => //.
  case: H_or => H_or.
    move: H_or => [H_or H_find].
    left; split => //.
    apply first_firstin in H_fst.
    apply dequeue_dequeued in H_deq.
    apply Logic.eq_sym.
    rewrite -H_or.
    move: H_fst H_deq.
    exact: firstin_dequeue_neq_eq_count_eq.
  move: H_or => [H_find H_q].
  right; split => //.
  move => lvo5 H_q'.
  apply dequeue_dequeued in H_deq.
  have H_qq: In_queue (msg_status 0 lvo5) q5.
    move: H_deq H_q'.
    exact: dequeued_in_after_in_before.
  contradict H_qq.
  exact: H_q.
- (* status_neq *)
  move => T5 i5 q5 I5 b5 l5 q' j lv5 t5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  rewrite /=.
  move => H_ok H_in H_bef H_eq H_ins.
  have H_or := H_eq.
  apply H_bef in H_or => //.
  rewrite H_eq in H_or.
  rewrite H_eq.
  have H_inn: In t_before (t_before :: T5) by left.
  have H_inn': In t5 (t_before :: T5) by right.
  case (eq_i j 0) => H_eq'.
    rewrite H_eq' in H_fst.
    apply first_firstin in H_fst.
    have H_q := H_fst.
    apply firstin_in_queue in H_q.
    have H_eq'' := bfs_net_ok_root_status_in_queue _ H_ok _ H_inn _ H_q.
    rewrite -H_eq''.
    right; rewrite IMapFacts.add_eq_o => //.
    split => //.
    move => lvo5 H_q'.
    injection H_eq'' => H_eq_lv {H_eq''}.
    rewrite H_eq_lv in H_lv, H_fst, H_q.
    apply dequeue_dequeued in H_deq.
    have H_q'': In_queue (msg_status 0 lvo5) q5.
      move: H_q'.
      exact: dequeued_in_after_in_before.
    have H_lv_eq := bfs_net_ok_root_status_in_queue _ H_ok _ H_inn _ H_q''.
    rewrite H_lv_eq {H_q'' H_lv_eq} in H_q'.
    case: H_or => H_or.
      move: H_or => [H_or H_find].      
      have H_cnt: count_eq eq_msg (msg_status 0 (Some 0)) q' = 0 by move: H_or H_fst H_deq; exact: firstin_dequeue_less.
      by apply notin_queue_count_eq_0_iff in H_cnt.
    move: H_or => [H_find H_nq].
    contradict H_q.
    exact: H_nq.
  rewrite IMapFacts.add_neq_o => //.
  case: H_or => H_or.
    move: H_or => [H_or H_find].
    left; split => //.
    apply first_firstin in H_fst.
    apply dequeue_dequeued in H_deq.
    apply Logic.eq_sym.
    rewrite -H_or.
    move: H_fst H_deq.
    apply: firstin_dequeue_neq_eq_count_eq => //.
    by move => H_eq''; injection H_eq'' => H_eq_lv H_eq_i; apply Logic.eq_sym in H_eq_i.
  move: H_or => [H_find H_q].
  right.
  split => //.
  move => lvo5 H_q'.
  apply dequeue_dequeued in H_deq.
  have H_qq: In_queue (msg_status 0 lvo5) q5.
    move: H_deq H_q'.
    exact: dequeued_in_after_in_before.
  contradict H_qq.
  exact: H_q.
- (* status_neq_bot *)
  move => T5 i5 q5 I5 b5 L5 q' j t5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  rewrite /=.
  move => H_ok H_in H_bef H_eq H_ins.
  have H_or := H_eq.
  apply H_bef in H_or => //.  
  rewrite H_eq in H_or.
  rewrite H_eq.
  have H_inn: In t_before (t_before :: T5) by left.
  have H_inn': In t5 (t_before :: T5) by right.
  have H_neq': j <> 0.
    move => H_eq'.
    rewrite H_eq' in H_fst.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    by have H_eq'' := bfs_net_ok_root_status_in_queue _ H_ok _ H_inn _ H_fst.
  rewrite IMapFacts.remove_neq_o => //.
  case: H_or => H_or.
    move: H_or => [H_or H_find].
    left; split => //.
    apply first_firstin in H_fst.
    apply dequeue_dequeued in H_deq.
    apply Logic.eq_sym.
    rewrite -H_or.
    move: H_fst H_deq.
    exact: firstin_dequeue_neq_eq_count_eq.
  move: H_or => [H_find H_q].
  right; split => //.
  move => lvo5 H_q'.
  apply dequeue_dequeued in H_deq.
  have H_qq: In_queue (msg_status 0 lvo5) q5.
    move: H_deq H_q'.
    exact: dequeued_in_after_in_before.
  contradict H_qq.
  exact: H_q.
- (* status_root *)
  move => T5 q5 I5 b5 L5 q' j lvo5 H_fst H_deq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_eq H_ins.
  have H_inn: In t_before (t_before :: T5) by left.
  contradict H_ins.
  exact: (not_adjacent_self_bfs _ H_ok _ H_inn).
- (* status_root *)
  move => T5 q5 I5 b5 L5 q' j lvo5 t5 H_fst H_deq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_eq H_ins.
  apply bfs_net_ok_nodup in H_ok.
  inversion H_ok; subst.
  contradict H1.
  apply InA_alt.
  by exists t5.
- (* init *)
  move => T5 T' i5 H_ok H_fresh H_eq H_ins.
  by inversion H_ins.
- (* init *)
  move => T5 T' i5 t' H_ok H_fresh H_in H_eq H_ins.
  by inversion H_ins.
- (* init *)
  move => T5 T' i5 t5 H_ok H_fresh H_in H_eq H_ins.
  have H_inn: In t5 (T5 ++ T') by apply in_or_app; left.
  by have H_fr := fresh_not_in_adj_bfs _ H_ok _ H_fresh _ H_inn.
- (* init *)
  move => T5 T' i5 t' q5 H_ok H_fresh H_eq.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_in H_eq' H_ins.
  by inversion H_ins.
- (* init *)
  move => T5 T' i5 q5 t5 t' H_ok H_fresh H_eq.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_in H_in' H_bef H_eq' H_ins.
  rewrite H_eq /=.
  have H_or := H_eq'.
  apply H_bef in H_or => //.  
  case: H_or => H_or; first by left.
  move: H_or => [H_find H_q].
  right.
  split => //.
  move => lvo5 H_q'.
  case: H_q' => H_q' //.
  contradict H_q'.
  exact: H_q.
- (* init *)
  move => T5 T' i5 q5 t5 H_ok H_fresh H_eq.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_eq' H_ins.
  have H_inn: In t5_before (T5 ++ T') by apply in_or_app; right.
  by have H_fr := fresh_not_in_adj_bfs _ H_ok _ H_fresh _ H_inn.
- (* init *)
  move => T5 T' i5 q5 q' t5 t' H_ok H_fresh H_eq H_eq'.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  set t'_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_in' H_bef H_eq'' H_ins.
  rewrite H_eq' /=.
  have H_or := H_eq''.
  apply H_bef in H_or => //.  
  case: H_or => H_or; first by left.
  move: H_or => [H_find H_q].
  right.
  split => //.
  move => lvo5 H_q'.
  case: H_q' => H_q' //.
  contradict H_q'.
  exact: H_q.
- (* fail *)
  move => T5 i5 q' I5 b5 L5 t5 t6 q5 q6.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  set t'_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_eq H_eq' H_in H_in' H_bef H_eq'' H_ins.
  rewrite H_eq' /=.
  have H_or := H_eq''.
  apply H_bef in H_or => //.  
  case: H_or => H_or; first by left.
  move: H_or => [H_find H_q].
  right.
  split => //.
  move => lvo5 H_q'.
  case: H_q' =>  H_q' //.
  contradict H_q'.
  exact: H_q.
- (* fail *)
  move => T5 i5 q' I5 b5 l5 t5 t6 q6.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t6_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_eq H_in H_in' H_bef H_eq' H_ins.
  rewrite H_eq' /=.
  have H_or := H_eq'.
  apply H_bef in H_or => //.  
  rewrite H_eq' in H_or.
  rewrite H_eq /=.
  case: H_or => H_or; first by left.
  move: H_or => [H_find H_q].
  right.
  split => //.
  move => lvo5 H_q'.
  case: H_q' =>  H_q' //.
  contradict H_q'.
  exact: H_q.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  rewrite /=.
  move => H_ok H_bef H_eq H_ins.
  rewrite H_eq /=.  
  have H_or := H_eq.
  apply H_bef in H_or => //.  
  rewrite H_eq in H_or.
  case: H_or => H_or.
    move: H_or => [H_or H_find].
    left; split => //.
    apply first_firstin in H_fst.
    apply dequeue_dequeued in H_deq.
    apply Logic.eq_sym.
    rewrite -H_or.
    move: H_fst H_deq.
    exact: firstin_dequeue_neq_eq_count_eq.
  move: H_or => [H_find H_q].
  right; split => //.
  move => lvo5 H_q'.
  apply dequeue_dequeued in H_deq.
  have H_qq: In_queue (msg_status 0 lvo5) q5.
    move: H_deq H_q'.
    exact: dequeued_in_after_in_before.
  contradict H_qq.
  exact: H_q.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t1_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_eq H_ins.
  have H_inn': In t1_before (t0_before :: t1_before :: T5) by right; left.
  contradict H_ins.
  exact: (not_adjacent_self_bfs _ H_ok _ H_inn').
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 t5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_eq H_ins.
  rewrite H_eq /=.
  have H_or := H_eq.
  apply H_bef in H_or => //.  
  rewrite H_eq in H_or.
  case: H_or => H_or.
    move: H_or => [H_or H_find].
    left; split => //.
    apply first_firstin in H_fst.
    apply dequeue_dequeued in H_deq.
    apply Logic.eq_sym.
    rewrite -H_or.
    move: H_fst H_deq.
    exact: firstin_dequeue_neq_eq_count_eq.
  move: H_or => [H_find H_q].
  right; split => //.
  move => lvo5 H_q'.
  apply dequeue_dequeued in H_deq.
  have H_qq: In_queue (msg_status 0 lvo5) q5.
    move: H_deq H_q'.
    exact: dequeued_in_after_in_before.
  contradict H_qq.
  exact: H_q.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 t5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t1_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_eq H_ins.
  rewrite H_eq.
  have H_or := H_eq.
  apply H_bef in H_or => //.  
  rewrite H_eq in H_or.
  case: H_or => H_or.
    move: H_or => [H_or H_find].
    left; split => //.
    rewrite count_eq_enqueue_monotonic //.
    by move => H_eq'; injection H_eq' => H_eq_lv H_eq_i; apply Logic.eq_sym in H_eq_i.
  move: H_or => [H_find H_q].
  right; split => //.
  move => lvo5 H_q'.
  rewrite /= in H_q'.
  case: H_q' => H_q'; first by injection H_q' => H_eq_lv H_eq_i; rewrite H_eq_i in H_neq.
  contradict H_q'.
  exact: H_q.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 t5 H_fst H_deq H_lv H_neq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_eq H_ins.
  rewrite H_eq /=.
  have H_or := H_eq.
  apply H_bef in H_or => //.  
  rewrite H_eq in H_or.
  case: H_or => H_or.
    move: H_or => [H_or H_find].
    left; split => //.
    apply first_firstin in H_fst.
    apply dequeue_dequeued in H_deq.
    apply Logic.eq_sym.
    rewrite -H_or.
    move: H_fst H_deq.
    exact: firstin_dequeue_neq_eq_count_eq.
  move: H_or => [H_find H_q].
  right; split => //.
  move => lvo5 H_q'.
  apply dequeue_dequeued in H_deq.
  have H_qq: In_queue (msg_status 0 lvo5) q5.
    move: H_deq H_q'.
    exact: dequeued_in_after_in_before.
  contradict H_qq.
  exact: H_q.
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t0_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_eq H_ins.
  have H_neq: j <> 0.
    move => H_eq'.
    apply bfs_net_ok_nodup in H_ok.
    inversion H_ok.
    contradict H1.
    apply InA_alt.
    exists t1_before.
    split; last by left.
    apply eq_ident_refl => /=.
    by rewrite H_eq'.
  rewrite /= in H_ins.
  apply ISetFacts.add_3 in H_ins => //.  
  have H_or := H_eq.
  apply H_bef in H_or => //.
  case: H_or => H_or.
    move: H_or => [H_or H_find].
    left; split => //.
    apply first_firstin in H_fst.
    apply dequeue_dequeued in H_deq.
    apply Logic.eq_sym.
    rewrite -H_or.
    move: H_fst H_deq.
    exact: firstin_dequeue_neq_eq_count_eq.
  move: H_or => [H_find H_q].
  right; split => //.
  move => lvo5 H_q'.
  apply dequeue_dequeued in H_deq.
  have H_qq: In_queue (msg_status 0 lvo5) q5.
    move: H_deq H_q'.
    exact: dequeued_in_after_in_before.
  contradict H_qq.
  exact: H_q.
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t0_after := mk_nd_bfs _ _ _ _ _.
  set t1_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_eq H_ins.
  rewrite /=.
  rewrite /= in H_ins.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_inn: In t0_before (t0_before :: t1_before :: T5) by left.
  have H_inn': In t1_before (t0_before :: t1_before :: T5) by right; left.
  have H_ins': ~ ISet.In j I5.
    apply firstin_in_queue in H_fst.
    by apply (in_queue_not_in_adj_bfs _ H_ok _ H_inn _ H_fst).
  left; split; last exact: bfs_net_ok_notin_adj_find_none _ H_ok _ _ H_inn H_inn' H_ins'.
  suff H_suff: count_eq eq_msg (msg_status 0 (Some 0)) q' = 0 by rewrite /= /count_P /fold_count_P /AP_dec /=; omega.
  suff H_suff: ~ In_queue (msg_status 0 (Some 0)) q' by apply notin_queue_count_eq_0_iff.        exact: (bfs_net_ok_notin_adj_not_sent_status _ H_ok _ _ H_inn H_inn' H_ins').  
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t1_after := mk_nd_bfs _ _ _ _ _.
  set t0_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_eq H_ins.
  apply bfs_net_ok_nodup in H_ok.
  inversion H_ok.
  contradict H1.
  apply InA_alt.
  exists t1_before.
  by split; last by left.
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t1_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_eq H_ins.
  have H_inn': In t1_before (t0_before :: t1_before :: T5) by right; left.
  contradict H_ins.
  exact: (not_adjacent_self_bfs _ H_ok _ H_inn').
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' t' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t0_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_eq H_ins.
  have H_neq': j <> bfs_ident t'.
    move => H_eq'.
    apply bfs_net_ok_nodup in H_ok.
    inversion H_ok.
    inversion H2.
    contradict H5.
    apply InA_alt.
    by exists t'.
  rewrite /= in H_ins.
  apply ISetFacts.add_3 in H_ins => //.  
  exact: H_bef.
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' t' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t0_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_eq H_ins.
  apply bfs_net_ok_nodup in H_ok.
  inversion H_ok.
  contradict H1.
  apply InA_alt.
  exists t'.
  by split; last by right.
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' t' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  set t1_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_eq H_ins.
  rewrite H_eq /=.
  left.
  have H_inn: In t0_before (t0_before :: t1_before :: T5) by left.
  have H_inn': In t1_before (t0_before :: t1_before :: T5) by right; left.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_ins': ~ ISet.In j I5.
    apply firstin_in_queue in H_fst.
    by apply (in_queue_not_in_adj_bfs _ H_ok _ H_inn _ H_fst).
  split; last exact: bfs_net_ok_notin_adj_find_none _ H_ok _ _ H_inn H_inn' H_ins'.
  suff H_suff: count_eq eq_msg (msg_status 0 (Some 0)) q' = 0 by rewrite /= /count_P /fold_count_P /AP_dec /=; omega.
  suff H_suff: ~ In_queue (msg_status 0 (Some 0)) q' by apply notin_queue_count_eq_0_iff.
  exact: (bfs_net_ok_notin_adj_not_sent_status _ H_ok _ _ H_inn H_inn' H_ins').
- (* new_root_ex *)
  move => T5 q5 I5 b5 l5 q' j H_fst H_deq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_eq H_ins.
  have H_inn: In t_before (t_before :: T5) by left.
  have H_neq: j <> 0.
    move => H_eq'.
    rewrite H_eq' in H_fst.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    by have H_nots := not_self_in_queue_bfs _ H_ok _ H_inn.
  rewrite /= in H_ins.
  apply ISetFacts.add_3 in H_ins => //.
  contradict H_ins.
  exact: (not_adjacent_self_bfs _ H_ok _ H_inn).
- (* new_root_ex *)
  move => T5 q5 I5 b5 L5 q' j t5 H_fst H_deq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_eq H_ins.
  have H_neq: j <> bfs_ident t5.
    move => H_eq'.
    case: H_ex.
    by exists t5; split. 
  rewrite /= in H_ins.
  apply ISetFacts.add_3 in H_ins => //.
  exact: H_bef.
- (* new_root_ex *)
  move => T5 q5 I5 b5 L5 q' j t5 H_fst H_deq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t_after := mk_nd_bfs _ _ _ _ _. 
  move => H_ok H_in H_bef H_eq H_ins.
  apply bfs_net_ok_nodup in H_ok.
  inversion H_ok.
  contradict H1.
  apply InA_alt.
  exists t5.
  by split.
- (* broadcast *)
  move => T5 i5 q5 I5 L5 t5 t' q' q'' H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  set t'_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_q H_q' H_in H_in' H_ins H_ins' H_bef H_eq H_ins''.
  rewrite H_q'.
  have H_or := H_eq.
  apply H_bef in H_or => //.  
  case: H_or => H_or.
    move: H_or => [H_or H_find].
    left; split => //.
    rewrite count_eq_enqueue_monotonic //.
    rewrite H_eq.
    by move => H_eq'; injection H_eq' => H_eq_lv H_eq_i; apply Logic.eq_sym in H_eq_i.
  move: H_or => [H_find H_qq].
  right; split => //.
  move => lvo5 H_qq'.
  case: H_qq' => H_qq'.
    injection H_qq' => H_eq_l H_eq_i.
    by rewrite -H_eq H_eq_i in H_neq.
  rewrite -/(In_queue _ _) in H_qq'.
  rewrite /= in H_qq.
  contradict H_qq'.
  exact: H_qq.
- (* broadcast *)
  move => T5 i5 q5 I5 L5 t5 t' q' H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_eq' H_in H_in' H_ins H_ins' H_bef H_eq H_ins''.
  rewrite H_eq'.
  have H_or := H_eq.
  apply H_bef in H_or => //.
  case: H_or => H_or.
    move: H_or => [H_or H_find].
    left; split => //.
    rewrite count_eq_enqueue_monotonic //.
    rewrite H_eq.
    by move => H_eq''; injection H_eq'' => H_eq_lv H_eq_i; apply Logic.eq_sym in H_eq_i.
  move: H_or => [H_find H_qq].
  right; split => //.
  move => lvo5 H_qq'.
  case: H_qq' => H_qq'.
    injection H_qq' => H_eq_l H_eq_i.
    by rewrite -H_eq H_eq_i in H_neq.
  rewrite -/(In_queue _ _) in H_qq'.
  rewrite /= in H_qq.
  contradict H_qq'.
  exact: H_qq.
Qed.
  
Lemma bfs_net_ok_root_have_level_in_queue : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 t' : t), In t5 T5 -> In t' T5 ->
  bfs_ident t5 = 0 ->
  ISet.In (bfs_ident t') (bfs_adj t5) ->
  In_queue (msg_status (bfs_ident t5) (Some 0)) (bfs_mbox t') \/ IMap.find (bfs_ident t5) (bfs_levels t') = Some 0.
Proof.
move => T5 H_ok t5 t' H_in H_in' H_eq H_ins.
case (bfs_net_ok_root_have_level _ H_ok _ _ H_in H_in' H_eq H_ins) => H_or.
  move: H_or => [H_or H_find].
  left.
  apply (in_queue_count_gt_0_iff eq_msg _ (bfs_mbox t')).
  by omega.
move: H_or => [H_find H_q].
by right.
Qed.

Lemma bfs_net_ok_nonroot_have_level : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 t' : t), In t5 T5 -> In t' T5 ->
  bfs_ident t5 <> 0 -> bfs_ident t' <> 0 ->
  forall (lv5 : lv), level (bfs_adj t5) (bfs_levels t5) = Some lv5 ->
  ISet.In (bfs_ident t') (bfs_adj t5) ->
  bfs_broadcast t5 = true \/ 
  (In_queue (msg_status (bfs_ident t5) (Some lv5)) (bfs_mbox t') /\ (forall (lvo5 : lvo), lvo5 <> Some lv5 -> In_queue_after_first (msg_status (bfs_ident t5) (Some lv5)) (msg_status (bfs_ident t5) lvo5) (bfs_mbox t'))) \/
  (IMap.find (bfs_ident t5) (bfs_levels t') = Some lv5 /\ (forall (lvo5 : lvo), ~ In_queue (msg_status (bfs_ident t5) lvo5) (bfs_mbox t'))).
Proof.
move => T5 H_ok t5 t' H_in H_in'.
pose P_curr (t5 t' : t) := bfs_ident t5 <> 0 -> bfs_ident t' <> 0 ->
  forall (lv5 : lv), level (bfs_adj t5) (bfs_levels t5) = Some lv5 ->
  ISet.In (bfs_ident t') (bfs_adj t5) ->
  bfs_broadcast t5 = true \/ 
  (In_queue (msg_status (bfs_ident t5) (Some lv5)) (bfs_mbox t') /\ (forall (lvo5 : lvo), lvo5 <> Some lv5 -> In_queue_after_first (msg_status (bfs_ident t5) (Some lv5)) (msg_status (bfs_ident t5) lvo5) (bfs_mbox t'))) \/
  (IMap.find (bfs_ident t5) (bfs_levels t') = Some lv5 /\ (forall (lvo5 : lvo), ~ In_queue (msg_status (bfs_ident t5) lvo5) (bfs_mbox t'))).
rewrite -/(P_curr _ _).
apply (P_inv_dual_bfs T5); rewrite /P_curr //= {H_ok T5 H_in H_in' t5 t' P_curr}.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_neq' H_neq'' lv5 H_eq H_ins.
  have H_inn: In t_before (t_before :: T5) by left.
  have H_neq''': j <> i5.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    move => H_eq'.
    contradict H_fst.
    rewrite H_eq'.
    exact: (not_self_in_queue_bfs _ H_ok _ H_inn).
  apply ISetFacts.add_3 in H_ins => //.
  contradict H_ins.
  exact: (not_adjacent_self_bfs _ H_ok _ H_inn).
- (* new *)
  move => T5 i5 q5 I5 b5 L5 q' j t' H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv5 H_eq H_ins.
  have H_inn: In t_before (t_before :: T5) by left.
  have H_inn': In t' (t_before :: T5) by right.
  have H_ins': ~ ISet.In j I5 by exact: (bfs_net_ok_queue_new_not_in_adj _ H_ok _ H_inn _ H_fst).
  have H_lv' := bfs_net_ok_notins_levels_bot _ H_ok _ H_inn _ H_ins'. 
  apply (level_add_bot_eq I5) in H_lv'.
  rewrite /= in H_lv'.
  by rewrite H_lv H_eq in H_lv'.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 q' j t5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv5 H_lv' H_ins.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_or := H_lv'.
  apply H_bef in H_or => //.  
  case: H_or => H_or; first by left.
  case: H_or => H_or.
    right; left.
    move: H_or => [H_in_q H_af].
    split; first exact: (dequeued_neq_in_before_in_after _ _ _ _ _ H_fst H_deq).
    move => lvo5 H_neq_lv.
    apply H_af in H_neq_lv.
    move: H_neq_lv.
    exact: dequeue_after_first.
  right; right.
  move: H_or => [H_find H_q].
  split => //.
  move => lvo5 H_q'.
  have H_qq := H_q lvo5.
  contradict H_qq.
  move: H_q'.
  exact: dequeued_in_after_in_before.
- (* fail *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_neq' H_neq'' lv5 H_lv' H_ins.
  have H_inn: In t_before (t_before :: T5) by left.
  apply ISetFacts.remove_3 in H_ins.
  contradict H_ins.
  exact: (not_adjacent_self_bfs _ H_ok _ H_inn).
- (* fail *)
  move => T5 i5 q5 I5 b5 L5 q' j t' H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv5 H_lv' H_ins.
  rewrite H_lv' in H_lv.
  apply ISetFacts.remove_3 in H_ins.
  exact: H_bef.
- (* fail *)
  move => T5 i5 q5 I5 b5 L5 q' j t5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv5 H_lv' H_ins.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_inn: In t_before (t_before :: T5) by left.
  have H_inn': In t5 (t_before :: T5) by right.
  have H_neq''': j <> bfs_ident t5.
    move => H_eq.
    apply firstin_in_queue in H_fst.
    contradict H_fst.
    rewrite H_eq.
    by have H_notin := in_network_no_id_fails_inv_bfs _ H_ok _ _ H_inn' H_inn.
  rewrite IMapFacts.remove_neq_o => //.
  have H_or := H_lv'.
  apply H_bef in H_or => //.  
  case: H_or => H_or; first by left.
  case: H_or => H_or.
    right; left.
    move: H_or => [H_in_q H_af].
    split; first exact: (dequeued_neq_in_before_in_after _ _ _ _ _ H_fst H_deq).
    move => lvo5 H_neq_lv.
    apply H_af in H_neq_lv.
    move: H_neq_lv.
    exact: dequeue_after_first.  
  right; right.
  move: H_or => [H_find H_q].
  split => //.
  move => lvo5 H_q'.
  have H_qq := H_q lvo5.
  contradict H_qq.
  move: H_q'.
  exact: dequeued_in_after_in_before.
- (* fail *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_neq' H_neq'' lv5 H_lv' H_ins.
  by left.
- (* fail *)
  move => T5 i5 q5 I5 b5 L5 q' j t5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv5 H_lv' H_ins.
  by left.
- (* fail *)
  move => T5 i5 q5 I5 b5 L5 q' j t5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv5 H_lv' H_ins.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_inn: In t_before (t_before :: T5) by left.
  have H_inn': In t5 (t_before :: T5) by right.
  have H_neq''': j <> bfs_ident t5.
    move => H_eq.
    apply firstin_in_queue in H_fst.
    contradict H_fst.
    rewrite H_eq.
    by have H_notin := in_network_no_id_fails_inv_bfs _ H_ok _ _ H_inn' H_inn.
  rewrite IMapFacts.remove_neq_o => //.
  have H_or := H_lv'.
  apply H_bef in H_or => //.  
  case: H_or => H_or; first by left.
  case: H_or => H_or.
    right; left.
    move: H_or => [H_in_q H_af].
    split; first exact: (dequeued_neq_in_before_in_after _ _ _ _ _ H_fst H_deq).
    move => lvo5 H_neq_lv.
    apply H_af in H_neq_lv.
    move: H_neq_lv.
    exact: dequeue_after_first.  
  right; right.
  move: H_or => [H_find H_q].
  split => //.
  move => lvo5 H_q'.
  have H_qq := H_q lvo5.
  contradict H_qq. 
  move: H_q'.
  exact: dequeued_in_after_in_before.
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_neq' H_neq'' lv' H_lv' H_ins.
  have H_inn: In t_before (t_before :: T5) by left.
  contradict H_ins.
  exact: (not_adjacent_self_bfs _ H_ok _ H_inn).
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 t' H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv' H_lv' H_ins.
  rewrite H_lv' in H_lv.
  exact: H_bef.
- (* status *)  
  move => T5 i5 q5 I5 b5 L5 q' j lv5 t5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv' H_lv' H_ins.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_or := H_lv'.
  apply H_bef in H_or => //.  
  case: H_or => H_or; first by left.
  case: H_or => H_or.    
    right.
    move: H_or => [H_in_q H_af].
    case (eq_msg (msg_status j (Some lv5)) (msg_status (bfs_ident t5) (Some lv'))) => H_eq; last first.
      left.
      split; first exact: (dequeued_neq_in_before_in_after _ _ _ _ _ H_fst H_deq).
      move => lvo5 H_neq_lv.
      apply H_af in H_neq_lv.
      move: H_neq_lv.
      exact: dequeue_after_first.  
    case (In_queue_dec eq_msg (msg_status (bfs_ident t5) (Some lv')) q') => H_eq'.
      left.
      split => //.
      move => lvo5 H_neq_lv.
      apply H_af in H_neq_lv.
      move: H_neq_lv.
      exact: dequeue_after_first.  
    right.
    injection H_eq => H_eq_id H_eq_lv.
    rewrite H_eq_id H_eq_lv.
    rewrite IMapFacts.add_eq_o => //.
    split => //.
    move => lvo5 H_q.
    case (eq_lvo lvo5 (Some lv')) => H_eq''; first by rewrite H_eq'' in H_q.
    have H_aft := H_af _ H_eq''.
    contradict H_q.
    rewrite H_eq_id H_eq_lv in H_fst.
    move: H_eq' H_aft.
    exact: dequeue_first_no_after_firsts.
  move: H_or => [H_find H_q].
  have H_neq_j: j <> bfs_ident t5.
    move => H_eq.
    rewrite -H_eq in H_q.
    apply firstin_in_queue in H_fst.
    by have H_qq := H_q (Some lv5).
  right; right.
  rewrite IMapFacts.add_neq_o => //.
  split => //.
  move => lvo5 H_q'.
  have H_qq := H_q lvo5.
  contradict H_qq.
  move: H_deq H_q'.
  exact: dequeued_in_after_in_before.
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_neq' H_neq'' lv5 H_lv' H_ins.
  have H_inn: In t_before (t_before :: T5) by left.
  contradict H_ins.
  exact: (not_adjacent_self_bfs _ H_ok _ H_inn).
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j t' H_fst H_deq H_lv' H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv5 H_lv5 H_ins.
  rewrite -H_lv' in H_lv5.
  exact: H_bef.
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j t5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv5 H_lv5 H_ins.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_or := H_lv5.
  apply H_bef in H_or => //.  
  case: H_or => H_or; first by left.
  case: H_or => H_or.
    move: H_or => [H_q H_aft].
    right; left.
    split; first exact: (dequeued_neq_in_before_in_after _ _ _ _ _ H_fst H_deq).
    move => lvo5 H_neq_lv.
    apply H_aft in H_neq_lv.
    move: H_neq_lv.
    exact: dequeue_after_first.  
  move: H_or => [H_q H_aft].
  have H_neq_lv: j <> bfs_ident t5.
    move => H_eq.
    apply firstin_in_queue in H_fst.
    rewrite H_eq in H_fst.
    by contradict H_fst.   
  right; right.
  rewrite IMapFacts.remove_neq_o => //.
  split => //.
  move => lvo5 H_q'.
  have H_aft' := H_aft lvo5.
  contradict H_aft'.
  move: H_deq H_q'.
  exact: dequeued_in_after_in_before.
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_neq' H_neq'' lv' H_lv' H_ins.
  have H_inn: In t_before (t_before :: T5) by left.
  contradict H_ins.
  exact: (not_adjacent_self_bfs _ H_ok _ H_inn).  
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 t' H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv' H_lv' H_ins.
  by left.
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 t' H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv' H_lv' H_ins.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_or := H_lv'.
  apply H_bef in H_or => //.    
  case: H_or => H_or; first by left.  
  case: H_or => H_or.
    right.
    move: H_or => [H_in_q H_af].
    case (eq_msg (msg_status j (Some lv5)) (msg_status (bfs_ident t') (Some lv'))) => H_eq; last first.
      left.
      split; first exact: (dequeued_neq_in_before_in_after _ _ _ _ _ H_fst H_deq).
      move => lvo5 H_neq_lv.
      apply H_af in H_neq_lv.
      move: H_neq_lv.
      exact: dequeue_after_first.  
    case (In_queue_dec eq_msg (msg_status (bfs_ident t') (Some lv')) q') => H_eq'.
      left.
      split => //.
      move => lvo5 H_neq_lv.
      apply H_af in H_neq_lv.
      move: H_neq_lv.
      exact: dequeue_after_first.  
    right.
    injection H_eq => H_eq_id H_eq_lv.
    rewrite H_eq_id H_eq_lv.
    rewrite IMapFacts.add_eq_o => //.
    split => //.
    move => lvo5 H_q.
    case (eq_lvo lvo5 (Some lv')) => H_eq''; first by rewrite H_eq'' in H_q.
    have H_aft := H_af _ H_eq''.
    contradict H_q.
    rewrite H_eq_id H_eq_lv in H_fst.
    move: H_eq' H_aft.
    exact: dequeue_first_no_after_firsts.
  move: H_or => [H_find H_q].
  have H_neq_j: j <> bfs_ident t'.
    move => H_eq.
    rewrite -H_eq in H_q.
    apply firstin_in_queue in H_fst.
    by have H_qq := H_q (Some lv5).
  right; right.
  rewrite IMapFacts.add_neq_o => //.
  split => //.
  move => lvo5 H_q'.
  have H_qq := H_q lvo5.
  contradict H_qq.
  move: H_deq H_q'.
  exact: dequeued_in_after_in_before.
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_neq' H_neq'' lv5 H_lv5 H_ins.  
  have H_inn: In t_before (t_before :: T5) by left.
  contradict H_ins.
  exact: (not_adjacent_self_bfs _ H_ok _ H_inn).  
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j t' H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv5 H_lv5 H_ins.
  by left.
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j t' H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv5 H_lv5 H_ins.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_or := H_lv5.
  apply H_bef in H_or => //.    
  case: H_or => H_or; first by left.  
  case: H_or => H_or.
    move: H_or => [H_q H_aft].
    right; left.
    split; first exact: (dequeued_neq_in_before_in_after _ _ _ _ _ H_fst H_deq).
    move => lvo5 H_neq_lv.
    apply H_aft in H_neq_lv.
    move: H_neq_lv.
    exact: dequeue_after_first.  
  move: H_or => [H_q H_aft].
  have H_neq_lv: j <> bfs_ident t'.
    move => H_eq.
    apply firstin_in_queue in H_fst.
    rewrite H_eq in H_fst.
    by contradict H_fst.   
  right; right.
  rewrite IMapFacts.remove_neq_o => //.
  split => //.
  move => lvo5 H_q'.
  have H_aft' := H_aft lvo5.
  contradict H_aft'.
  move: H_deq H_q'.
  exact: dequeued_in_after_in_before.
- (* init *)
  move => T5 T' i5 H_ok H_fresh H_neq H_neq' lv5 H_lv H_ins.
  by inversion H_ins.
- (* init *)
  move => T5 T' i5 t5 H_ok H_fresh H_in H_neq H_neq' lv5 H_lv H_ins.
  by inversion H_ins.
- (* init *)
  move => T5 T' i5 t5 H_ok H_fresh H_in H_neq H_neq' lv5 H_lv H_ins.
  have H_inn: In t5 (T5 ++ T') by apply in_or_app; left.
  by have H_fr := fresh_not_in_adj_bfs _ H_ok _ H_fresh _ H_inn.
- (* init *)
  move => T5 T' i5 t' q5 H_ok H_fresh H_eq.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_neq H_neq' lv5 H_lv H_ins.
  by inversion H_ins.
- (* init *)
  move => T5 T' i5 q5 t5 t' H_ok H_fresh H_eq.
  set t'_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_in' H_bef H_neq H_neq' lv5 H_lv H_ins.
  rewrite H_eq.
  have H_or := H_lv.
  apply H_bef in H_or => //.      
  case: H_or => H_or; first by left.
  case: H_or => H_or.
    move: H_or => [H_q H_aft].
    right; left.
    split; first by right.
    move => lvo5 H_neq''.
    right.
    split => //.
    exact: H_aft.
  move: H_or => [H_q H_aft].
  right; right.
  split => //.
  move => lvo5 H_q'.
  have H_aft' := H_aft lvo5.
  by case: H_q' => H_q'.
- (* init *)
  move => T5 T' i5 q5 t5 H_ok H_fresh H_eq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_neq H_neq' lv5 H_lv H_ins.
  have H_inn: In t_before (T5 ++ T') by apply in_or_app; right.
  by have H_fr := fresh_not_in_adj_bfs _ H_ok _ H_fresh _ H_inn.
- (* init *)
  move => T5 T' i5 q5 q' t5 t' H_ok H_fresh H_q H_q'.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  set t'_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_in' H_bef H_neq H_neq' lv5 H_lv H_ins.
  rewrite H_q'.
  have H_or := H_lv.  
  apply H_bef in H_or => //.      
  case: H_or => H_or; first by left.  
  case: H_or => H_or.
    move: H_or => [H_in_q H_aft].
    right; left.
    split; first by right.
    move => lvo5 H_neq''.
    right.
    split => //.
    exact: H_aft.
  move: H_or => [H_in_q H_aft].
  right; right.
  split => //.
  move => lvo5 H_in_q'.
  have H_aft' := H_aft lvo5.
  by case: H_in_q' => H_in_q'.
- (* fail *)
  move => T5 i5 q' I5 b5 L5 t5 t6 q5 q6.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_eq H_eq'.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  set t6_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_in' H_bef H_neq H_neq' lv5 H_lv H_ins.
  rewrite H_eq'.
  have H_or := H_lv.  
  apply H_bef in H_or => //.      
  case: H_or => H_or; first by left.  
  case: H_or => H_or.
    move: H_or => [H_in_q H_aft].
    right; left.
    split; first by right.
    move => lvo5 H_neq''.
    right.
    split => //.
    exact: H_aft.
  move: H_or => [H_in_q H_aft].
  right; right.
  split => //.
  move => lvo5 H_in_q'.
  have H_aft' := H_aft lvo5.
  by case: H_in_q' => H_in_q'.
- (* fail *)
  move => T5 i5 q' I5 b5 L5 t5 t6 q6.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_eq H_in.
  set t6_before := mk_nd_bfs _ _ _ _ _.
  move => H_in' H_bef H_neq H_neq' lv5 H_lv H_ins.
  rewrite H_eq.
  have H_or := H_lv.  
  apply H_bef in H_or => //.      
  case: H_or => H_or; first by left.  
  case: H_or => H_or.
    move: H_or => [H_in_q H_aft].
    right; left.
    split; first by right.
    move => lvo5 H_neq''.
    right.
    split => //.
    exact: H_aft.    
  move: H_or => [H_in_q H_aft].
  right; right.
  split => //.
  move => lvo5 H_in_q'.
  have H_aft' := H_aft lvo5.
  by case: H_in_q' => H_in_q'.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_neq' H_neq'' lv' H_lv' H_ins.
  have H_inn: In t0_before (t0_before :: t1_before :: T5) by left.
  have H_neq_j: j <> i5.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    move => H_eq'.
    contradict H_fst.
    rewrite H_eq'.
    exact: (not_self_in_queue_bfs _ H_ok _ H_inn).
  apply ISetFacts.add_3 in H_ins => //.
  contradict H_ins.
  exact: (not_adjacent_self_bfs _ H_ok _ H_inn).
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_neq' H_neq'' lv' H_lv' H_ins.
  have H_inn: In t0_before (t0_before :: t1_before :: T5) by left.
  have H_ins': ~ ISet.In j I5 by exact: (bfs_net_ok_queue_new_not_in_adj _ H_ok _ H_inn _ H_fst).
  have H_lv'' := bfs_net_ok_notins_levels_bot _ H_ok _ H_inn _ H_ins'. 
  apply (level_add_bot_eq I5) in H_lv''.
  rewrite /= in H_lv''.
  rewrite H_lv H_lv' in H_lv''.
  injection H_lv'' => H_eq.
  rewrite H_eq.
  right; left.
  split; first by left.
  move => lvo5 H_neq_lv.
  by left.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_neq' H_neq'' lv' H_lv' H_ins.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_or := H_lv'.  
  apply H_bef in H_or => //.      
  case: H_or => H_or; first by left.  
  case: H_or => H_or.
    move: H_or => [H_in_q H_aft].
    right; left.
    split; first exact: (dequeued_neq_in_before_in_after _ _ _ _ _ H_fst H_deq).
    move => lvo5 H_neq_lv.
    have H_aft' := H_aft _ H_neq_lv.
    move: H_deq H_aft'.
    exact: dequeue_after_first.
  move: H_or => [H_in_q H_aft].
  right; right.
  split => //.
  move => lvo5 H_in_q'.
  have H_aft' := H_aft lvo5.
  contradict H_aft'.
  move: H_in_q'.
  exact: dequeued_in_after_in_before.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_neq' H_neq'' lv' H_lv' H_ins.  
  have H_inn': In t1_before (t0_before :: t1_before :: T5) by right; left.  
  contradict H_ins.
  exact: (not_adjacent_self_bfs _ H_ok _ H_inn').  
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 t' H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv' H_lv' H_ins.
  have H_inn: In t0_before (t0_before :: t1_before :: T5) by left.
  have H_inn': In t1_before (t0_before :: t1_before :: T5) by right; left.  
  have H_ins': ~ ISet.In j I5 by exact: (bfs_net_ok_queue_new_not_in_adj _ H_ok _ H_inn _ H_fst).
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_lv'' := bfs_net_ok_notins_levels_bot _ H_ok _ H_inn _ H_ins'. 
  apply (level_add_bot_eq I5) in H_lv''.
  rewrite /= in H_lv''.
  rewrite H_lv H_lv' in H_lv''.
  injection H_lv'' => H_eq.
  rewrite -H_eq.  
  have H_neq_j: j <> bfs_ident t'.
    move => H_eq'.
    apply bfs_net_ok_nodup in H_ok.
    inversion H_ok.
    inversion H2.
    contradict H5.
    apply InA_alt.
    exists t'.
    by split.
  apply ISetFacts.add_3 in H_ins => //. 
  exact: H_bef.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 t5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv' H_lv' H_ins.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_or := H_lv'.
  apply H_bef in H_or => //.      
  case: H_or => H_or; first by left. 
  case: H_or => H_or.
    move: H_or => [H_in_q H_aft].
    right; left.
    split; first exact: (dequeued_neq_in_before_in_after _ _ _ _ _ H_fst H_deq).
    move => lvo5 H_neq_lv.
    have H_aft' := H_aft _ H_neq_lv.
    move: H_deq H_aft'.
    exact: dequeue_after_first.   
  move: H_or => [H_in_q H_aft].
  right; right.
  split => //.
  move => lvo5 H_in_q'.
  have H_aft' := H_aft lvo5.
  contradict H_aft'.
  move: H_in_q'.
  exact: dequeued_in_after_in_before.   
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 t5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.  
  move => H_ok H_in H_bef H_neq' H_neq'' lv' H_lv' H_ins.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_or := H_lv'.
  apply H_bef in H_or => //.      
  case: H_or => H_or; first by left.   
  have H_neq_i: bfs_ident t5 <> i5.
    move => H_eq.
    apply bfs_net_ok_nodup in H_ok.
    inversion H_ok.
    contradict H1.
    apply InA_alt.
    exists t5.
    split => //.
    by right.
  case: H_or => H_or.
    move: H_or => [H_in_q H_aft].
    right; left.    
    split; first by right.
    move => lvo5 H_neq_lvo.
    right.
    split; last by apply H_aft in H_neq_lvo.
    move => H_neq_msg.
    by injection H_neq_msg => H_eq_i H_eq_lv.    
  move: H_or => [H_in_q H_aft].
  right; right.
  split => //.
  move => lvo5 H_in_q'.
  case: H_in_q' => H_in_q'; first by injection H_in_q'.
  by have H_aft' := H_aft lvo5.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 H_fst H_deq H_lv H_neq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_neq' H_neq'' lv' H_lv' H_ins.
  have H_inn: In t_before (t_before :: T5) by left.
  have H_neq_j: j <> i5.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    move => H_eq'.
    contradict H_fst.
    rewrite H_eq'.
    exact: (not_self_in_queue_bfs _ H_ok _ H_inn).
  apply ISetFacts.add_3 in H_ins => //.
  contradict H_ins.
  exact: (not_adjacent_self_bfs _ H_ok _ H_inn).  
- (* new *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 t' H_fst H_deq H_lv H_neq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv' H_lv' H_ins.
  have H_inn: In t_before (t_before :: T5) by left.
  have H_ins': ~ ISet.In j I5 by exact: (bfs_net_ok_queue_new_not_in_adj _ H_ok _ H_inn _ H_fst).
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_lv'' := bfs_net_ok_notins_levels_bot _ H_ok _ H_inn _ H_ins'. 
  apply (level_add_bot_eq I5) in H_lv''.
  rewrite /= in H_lv''.
  rewrite H_lv H_lv' in H_lv''.
  injection H_lv'' => H_eq.
  rewrite -H_eq.  
  have H_neq_i: j <> bfs_ident t'.
    move => H_eq'.
    case: H_ex.
    by exists t'.
  apply ISetFacts.add_3 in H_ins => //.
  exact: H_bef.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 t5 H_fst H_deq H_lv H_neq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv' H_lv' H_ins.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_or := H_lv'.
  apply H_bef in H_or => //.
  case: H_or => H_or; first by left.
  case: H_or => H_or.
    move: H_or => [H_in_q H_aft].
    right; left.
    split; first exact: (dequeued_neq_in_before_in_after _ _ _ _ _ H_fst H_deq).
    move => lvo5 H_neq_lv.
    have H_aft' := H_aft _ H_neq_lv.
    move: H_deq H_aft'.
    exact: dequeue_after_first.     
  move: H_or => [H_in_q H_aft].
  right; right.
  split => //.
  move => lvo5 H_in_q'.
  have H_aft' := H_aft lvo5.
  contradict H_aft'.
  move: H_in_q'.
  exact: dequeued_in_after_in_before.    
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_neq' H_neq'' lv5 H_lv H_ins.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_or := H_lv.
  apply H_bef in H_or => //.
  case: H_or => H_or; first by left.
  case: H_or => H_or.
    move: H_or => [H_in_q H_aft].
    right; left.
    split; first by right.
    move => lvo5 H_neq_lvo.
    right; split; first by move => H_eq; injection H_eq.
    by apply H_aft in H_neq_lvo.
  move: H_or => [H_find H_aft].
  right; right.
  split => //.
  move => lvo5 H_q.
  case: H_q => H_q; first by injection H_q.
  by have H_aft' := H_aft lvo5.
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' t5 H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_in H_bef H_neq' H_neq'' lv5 H_lv5 H_ins.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  have H_or := H_lv5.
  apply H_bef in H_or => //.
  case: H_or => H_or; first by left.
  case: H_or => H_or.
    move: H_or => [H_in_q H_aft].
    right; left.
    split; first by right.
    move => lvo5 H_neq_lvo.
    right; split; first by move => H_eq; injection H_eq.
    by apply H_aft in H_neq_lvo.
  move: H_or => [H_find H_aft].
  right; right.
  split => //.
  move => lvo5 H_q.
  case: H_q => H_q; first by injection H_q.
  by have H_aft' := H_aft lvo5.
- (* broadcast *)
  move => T5 i5 q5 I5 L5 H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef H_neq' H_neq'' lv5 H_lv5 H_ins.
  have H_inn: In t_before (t_before :: T5) by left.  
  contradict H_ins.
  exact: (not_adjacent_self_bfs _ H_ok _ H_inn).  
- (* broadcast *)
  move => T5 i5 q5 I5 L5 t5 q' H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_eq.  
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_ins H_bef H_neq' H_neq'' lv5 H_lv5 H_ins'.
  rewrite H_eq H_lv5.
  right; left.
  split; first by left.
  move => lvo5 H_neq_lvo.
  by left.
- (* broadcast *)
  move => T5 i5 q5 I5 L5 t5 t' q' q'' H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_eq H_eq'.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  set t'_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_in' H_ins H_ins' H_bef H_neq' H_neq'' lv5 H_lv5 H_ins''.
  rewrite H_eq' /=.
  have H_neq_i: bfs_ident t5 <> i5.
    move => H_eq''.
    apply bfs_net_ok_nodup in H_ok.
    inversion H_ok.
    contradict H1.
    apply InA_alt.
    by exists t5_before.  
  have H_or := H_lv5.
  apply H_bef in H_or => //.
  case: H_or => H_or; first by left.
  case: H_or => H_or.
    move: H_or => [H_in_q H_aft].
    right; left.
    split; first by right.
    move => lvo5 H_neq_lv.
    right; split; first by move => H_eq''; injection H_eq''.
    by have H_aft' := H_aft _ H_neq_lv.
  move: H_or => [H_in_q H_aft].
  right; right.
  split => //.
  move => lvo5 H_q.
  case: H_q => H_q; first by injection H_q.
  by contradict H_q.
- (* timeout *)
  move => T5 i5 q5 I5 L5 t5 t' q' H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_eq.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_in' H_ins H_ins' H_bef H_neq' H_neq'' lv5 H_lv H_ins''.
  rewrite H_eq /=.
  have H_neq_i: bfs_ident t' <> i5.
    move => H_eq''.
    apply bfs_net_ok_nodup in H_ok.
    inversion H_ok.
    contradict H1.
    apply InA_alt.
    by exists t'.
  have H_or := H_lv.
  apply H_bef in H_or => //.
  case: H_or => H_or; first by left.
  case: H_or => H_or.
    move: H_or => [H_in_q H_aft].
    right; left.
    split; first by right.
    move => lvo5 H_neq_lv.
    right; split; first by move => H_eq''; injection H_eq''.
    by have H_aft' := H_aft _ H_neq_lv.
  move: H_or => [H_in_q H_aft].
  right; right.
  split => //.
  move => lvo5 H_q.
  case: H_q => H_q; first by injection H_q.
  by contradict H_q.
Qed.

Lemma bfs_net_ok_no_aggregates_locals_drops : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  forall (msg5 : msg) (j : i) (m5 : m), 
  (msg5 = msg_aggregate j m5 \/ msg5 = msg_local m5 \/ msg5 = msg_drop j m5) ->
  ~ In_queue msg5 (bfs_mbox t5).
Proof.
move => T5 H_ok t5 H_in.
pose P_curr (t5 : t) := forall (msg5 : msg) (j : i) (m5 : m),
   msg5 = msg_aggregate j m5 \/ msg5 = msg_local m5 \/ msg5 = msg_drop j m5 ->
   ~ In_queue msg5 (bfs_mbox t5).
rewrite -/(P_curr _).
apply (P_inv_bfs T5); rewrite /P_curr //= {H_ok T5 H_in t5 P_curr}.
- by eauto with queue_in.
- by eauto with queue_in.
- by eauto with queue_in.
- by eauto with queue_in.
- by eauto with queue_in.
- by eauto with queue_in.
- by eauto with queue_in.
- by eauto with queue_in.
- by eauto with queue_in.
- (* init *)
  move => T5 T' i5 H_ok H_fresh msg5 j m5 H_or {T5 H_ok H_fresh i5}.
  elim: T' => [|t5 T' IH] //.
  rewrite /=.
  move => H_q.
  case: H_q => H_q //.
  by case: H_or => [H_or|[H_or|H_or]]; rewrite H_or in H_q.
- (* init *)
  move => T5 T' i5 t5 q' H_ok H_fresh H_q.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_bef msg5 j m5 H_or.
  rewrite H_q /=.
  move => H_q'.
  case: H_q' => H_q'; first by case: H_or => [H_or|[H_or|H_or]]; rewrite H_or in H_q'.
  have H_bef' := H_bef msg5 j m5.
  by apply H_bef' in H_or.
- (* fail *)
  move => T5 i5 q56 I5 b5 L5 t5 q'.
  set t_before := mk_nd_bfs _ _ _ _ _.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_q H_in H_ins H_bef msg5 j m5 H_or.
  rewrite H_q /=.
  move => H_q'.
  case: H_q' => H_q'; first by case: H_or => [H_or|[H_or|H_or]]; rewrite H_or in H_q'.
  have H_bef' := H_bef msg5 j m5.
  by apply H_bef' in H_or.
- by eauto with queue_in.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef msg5 i6 m5 H_or.
  apply first_firstin in H_fst.
  apply dequeue_dequeued in H_deq.
  move => H_q.
  case: H_q => H_q; first by case: H_or => [H_or|[H_or|H_or]]; rewrite H_or in H_q.
  have H_bef' := H_bef msg5 i6 m5.
  by apply H_bef' in H_or.
- by eauto with queue_in.
- by eauto with queue_in.
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef msg5 i6 m5 H_or.
  move => H_q.
  case: H_q => H_q; first by case: H_or => [H_or|[H_or|H_or]]; rewrite H_or in H_q.
  have H_bef' := H_bef msg5 i6 m5.
  by apply H_bef' in H_or.
- by eauto with queue_in.
- (* broadcast *)
  move => T5 i5 q5 I5 L5 t5 q' H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_q.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_ins H_bef msg5 j m5 H_or.
  rewrite H_q /=.
  move => H_q'.
  case: H_q' => H_q'; first by case: H_or => [H_or|[H_or|H_or]]; rewrite H_or in H_q'.
  contradict H_q'.
  by apply: (H_bef msg5 j m5).
Qed.

Lemma bfs_net_ok_no_aggregates : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  forall (j : i) (m5 : m), ~ In_queue (msg_aggregate j m5) (bfs_mbox t5).
Proof.
move => T5 H_ok t5 H_in j m5.
have H_q := bfs_net_ok_no_aggregates_locals_drops _ H_ok _ H_in.
apply: (H_q _ j m5).
by left.
Qed.

Lemma bfs_net_ok_no_locals : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  forall (m5 : m), ~ In_queue (msg_local m5) (bfs_mbox t5).
Proof.
move => T5 H_ok t5 H_in m5.
have H_q := bfs_net_ok_no_aggregates_locals_drops _ H_ok _ H_in.
apply: (H_q _ 0 m5).
by right; left.
Qed.

Lemma bfs_net_ok_no_drops : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  forall (j : i) (m5 : m), ~ In_queue (msg_drop j m5) (bfs_mbox t5).
Proof.
move => T5 H_ok t5 H_in j m5.
have H_q := bfs_net_ok_no_aggregates_locals_drops _ H_ok _ H_in.
apply: (H_q _ j m5).
by right; right.
Qed.

Lemma bfs_net_ok_level_gt_zero : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  forall (lv5 : lv), level (bfs_adj t5) (bfs_levels t5) = Some lv5 ->
  lv5 > 0.
Proof.
move => T5 H_ok t5 H_in lv5 H_lv.
apply level_spec_some in H_lv.
move: H_lv => [j [lv' [H_min H_eq]]].
rewrite H_eq.
by auto with arith.
Qed.

Lemma bfs_net_ok_levels_some_in_adj : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  forall (j : i) (lv5 : lv), IMap.find j (bfs_levels t5) = Some lv5 ->
  ISet.In j (bfs_adj t5).
Proof.
move => T5 H_ok t5 H_in.
pose P_curr (t5 : t) := forall (j : i) (lv5 : lv), IMap.find j (bfs_levels t5) = Some lv5 -> ISet.In j (bfs_adj t5).
rewrite -/(P_curr _).
apply (P_inv_bfs T5); rewrite /P_curr //= {H_ok T5 H_in t5 P_curr}.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lv5 H_find.
  apply ISetFacts.add_2.
  exact: (H_bef _ lv5).
- (* fail *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lv5 H_find.
  have H_neq': j <> i6.
    move => H_eq.
    by rewrite H_eq IMapFacts.remove_eq_o in H_find.
  apply ISetFacts.remove_2 => //.
  apply: (H_bef _ lv5).
  by rewrite IMapFacts.remove_neq_o in H_find.
- (* fail *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lv5 H_find.
  have H_neq': j <> i6.
    move => H_eq.
    by rewrite H_eq IMapFacts.remove_eq_o in H_find.
  apply ISetFacts.remove_2 => //.
  apply: (H_bef _ lv5).
  by rewrite IMapFacts.remove_neq_o in H_find.
- (* fail *)
  move => T5 q5 I5 b5 L5 q' j H_fst H_deq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lv5 H_find.
  have H_in: In t_before (t_before :: T5) by left.
  have H_eq: bfs_ident t_before = 0 by [].
  have H_lv := bfs_net_ok_root_levels_bot _ H_ok _ H_in H_eq i6.
  by rewrite H_find in H_lv.
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lv' H_find.
  case (eq_i j i6) => H_eq.
    rewrite -H_eq.
    have H_in: In t_before (t_before :: T5) by left.
    exact: (bfs_net_ok_queue_status_in_adj _ H_ok _ H_in _ _ H_fst).
  rewrite IMapFacts.add_neq_o in H_find => //.
  exact: (H_bef _ lv').
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lv5 H_find.
  case (eq_i j i6) => H_eq.
    rewrite -H_eq.
    have H_in: In t_before (t_before :: T5) by left.
    exact: (bfs_net_ok_queue_status_in_adj _ H_ok _ H_in _ _ H_fst).
  rewrite IMapFacts.remove_neq_o in H_find => //.
  exact: (H_bef _ lv5).
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lv' H_find.
  case (eq_i j i6) => H_eq.
    rewrite -H_eq.
    have H_in: In t_before (t_before :: T5) by left.
    exact: (bfs_net_ok_queue_status_in_adj _ H_ok _ H_in _ _ H_fst).
  rewrite IMapFacts.add_neq_o in H_find => //.
  exact: (H_bef _ lv').
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lv' H_find.
  case (eq_i j i6) => H_eq.
    rewrite -H_eq.
    have H_in: In t_before (t_before :: T5) by left.
    exact: (bfs_net_ok_queue_status_in_adj _ H_ok _ H_in _ _ H_fst).
  rewrite IMapFacts.remove_neq_o in H_find => //.
  exact: (H_bef _ lv').
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lv' H_find.
  apply ISetFacts.add_2.
  exact: (H_bef _ lv').
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' H_fst H_deq H_neq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lv5 H_find.
  apply ISetFacts.add_2.
  exact: (H_bef _ lv5).
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lv5 H_find.
  apply ISetFacts.add_2.
  exact: (H_bef _ lv5).
- (* new *)
  move => T5 q5 I5 b5 L5 j q' H_fst H_deq H_ex.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 lv5 H_find.
  have H_in: In t_before (t_before :: T5) by left.
  have H_eq: bfs_ident t_before = 0 by [].
  have H_lv := bfs_net_ok_root_levels_bot _ H_ok _ H_in H_eq i6.
  by rewrite H_find in H_lv.
Qed.

Lemma levels_some_level_ge : forall (I5 : I) (L5 : L) (j : i) (lv5 : lv),
  ISet.In j I5 ->
  IMap.find j L5 = Some lv5 ->
  exists lv', level I5 L5 = Some lv' /\ lv' <= lv5 + 1.
Proof.
move => I5 L5 j lv5 H_ins H_find.
rewrite /level.
case (lev _).
  case => lv' /=.
  move => [i5 [lv'0 [H_min H_eq]]].
  rewrite H_eq {H_eq}.
  case (lt_eq_lt_dec lv5 lv'0) => H_dec; first case: H_dec => H_dec.
  - inversion H_min.
    have H_lv: level_in I5 L5 j lv5 by exact: in_level_in.
    by apply H0 in H_lv.
  - rewrite H_dec.
    by exists (lv'0 + 1).
  - exists (lv'0 + 1).
    split => //.
    by auto with arith.
move => H_ex.
case: H_ex.
exists j; exists lv5.
rewrite /=.
exact: in_level_in.
Qed.

Definition not_mass_message (msg5 : msg) : Prop :=
match msg5 with
| msg_aggregate _ _ => False
| msg_local _ => False
| msg_drop _ _ => False
| _ => True
end.

Definition not_mass_message_dec : forall (msg5 : msg), { not_mass_message msg5 }+{ ~ not_mass_message msg5 }.
by refine (fun (msg5 : msg) => 
  match msg5 with
  | msg_aggregate _ _ => right _ _
  | msg_local _ => right _ _
  | msg_drop _ _ => right _ _
  | _ => left _ _
  end).
Defined.

Definition remove_mass_messages := filter_P not_mass_message not_mass_message_dec.

Lemma adjacent_implies_adjacent_bfs : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 t' : t), In t5 T5 -> In t' T5 ->
  adjacent t5 t' -> adjacent t' t5.
Proof.
move => T5 H_ok.
apply project_churn_bfs_ok in H_ok.
case => i5 q5 I5 b5 L5 /=.
set t5 := mk_nd_bfs _ _ _ _ _.
case => j q' I' b' L' /=.
set t' := mk_nd_bfs _ _ _ _ _.
move => H_in H_in'.
set s5 := mk_nd_churn i5 (remove_except_new_fail q5) I5.
set s' := mk_nd_churn j (remove_except_new_fail q') I'.
have H_in_s5: In s5 (project_churn_bfs T5).
  have [T' [T6 H_eq]] := in_split t5 T5 H_in.
  rewrite H_eq.
  rewrite project_churn_bfs_distr.
  apply in_or_app.
  by right; left.
have H_in_s': In s' (project_churn_bfs T5).
  have [T7 [T8 H_eq]] := in_split _ _ H_in'.
  rewrite H_eq.
  rewrite project_churn_bfs_distr.
  apply in_or_app.
  by right; left.
move => H_in_q.
have H_ex := adjacent_implies_adjacent_churn (project_churn_bfs _) H_ok _ _ H_in_s5 H_in_s'.
have H_ad: @adjacent s s_as_actor_node s5 s'.
  move: H_in_q.
  rewrite /adjacent /= /ident_adjacent /=.
  move => H_or.
  case: H_or => H_or; first by left.
  right.
  exact: filter_P_in_queue.
apply H_ex in H_ad.
move: H_ad.
rewrite /adjacent /= /ident_adjacent /=.
move => H_or.
case: H_or => H_or; first by left.
right.
move: H_or.
exact: filter_P_in_after_in_before.
Qed.

Lemma adjacent_iff_adjacent_bfs : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 t' : t), In t5 T5 -> In t' T5 ->
  (adjacent t5 t' <-> adjacent t' t5).
Proof.
move => T5 H_ok t5 t' H_in H_in'.
split.
  move: T5 H_ok t5 t' H_in H_in'.
  exact: adjacent_implies_adjacent_bfs.
move: T5 H_ok t' t5 H_in' H_in.
exact: adjacent_implies_adjacent_bfs.
Qed.

Lemma adjacent_mutually_adjacent_churn : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 t' : t), In t5 T5 -> In t' T5 ->
  adjacent t5 t' -> mutually_adjacent t5 t'.
Proof.
move => T5 H_ok t5 t' H_in H_in' H_adj.
rewrite /mutually_adjacent.
split => //.
move: T5 H_ok t5 t' H_in H_in' H_adj.
exact: adjacent_implies_adjacent_bfs.
Qed.

Lemma bfs_net_ok_status_0_in_queue_then_root : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  forall (j : i), In_queue (msg_status j (Some 0)) (bfs_mbox t5) ->
  j = 0.
Proof.
move => T5 H_ok t5 H_in.
pose P_curr (t5 : t) := forall (j : i), In_queue (msg_status j (Some 0)) (bfs_mbox t5) -> j = 0.
rewrite -/(P_curr _).
apply (P_inv_bfs T5); rewrite /P_curr //= {H_ok T5 H_in t5 P_curr}.
- by eauto with queue_in.
- by eauto with queue_in.
- by eauto with queue_in.
- by eauto with queue_in.
- by eauto with queue_in.
- by eauto with queue_in.
- by eauto with queue_in.
- by eauto with queue_in.
- by eauto with queue_in.
- (* init *)
  move => T5 T' i5 H_ok H_fresh j H_q.
  contradict H_q.
  elim: T' {H_ok H_fresh T5} => //.
  move => t5 T5 H_q H_q'.
  by case: H_q' => H_q'.
- (* init *)
  move => T5 T' i5 t5 q' H_ok H_fresh H_q.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_bef j H_q'.
  rewrite H_q in H_q'.
  case: H_q' => H_q' => //.
  rewrite -/(In_queue _ _) in H_q'.
  exact: H_bef.
- (* fail *)
  move => T5 i5 q5 I5 b5 L5 t5 q'.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_q.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_or H_bef j H_q'.
  rewrite H_q in H_q'.
  case: H_q' => H_q' //.
  exact: H_bef.
- (* new *)
  by eauto with queue_in.
- (* new *)
  move => T5 i5 q5 I5 b5 L5 j q' I' b' L' q'' lv5 H_fst H_deq H_lv H_neq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 H_q.
  have H_in: In t0_before (t0_before :: t1_before :: T5) by left.
  have H_lv' := bfs_net_ok_level_gt_zero _ H_ok _ H_in _ H_lv.
  case: H_q => H_q.
    injection H_q => H_eq H_eq'.
    rewrite -H_eq in H_lv'.
    contradict H_lv'.
    by auto with arith.
  exact: H_bef.
- (* new *)
  by eauto with queue_in.
- (* new *)
  by eauto with queue_in.
- (* new *)
  move => T5 q5 I5 b5 L5 j q' I' b' L' q'' H_fst H_deq.
  set t0_before := mk_nd_bfs _ _ _ _ _.
  set t1_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 H_q.
  case: H_q => H_q; first by injection H_q.
  exact: H_bef.
- (* new *)
  by eauto with queue_in.
- (* timeout *)
  move => T5 i5 q5 I5 L5 t5 q' H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_q.
  set t5_before := mk_nd_bfs _ _ _ _ _.
  move => H_in H_ins H_bef i6 H_q'.
  rewrite H_q in H_q'.
  have H_in': In t_before (t_before :: T5) by left.
  have H_lv' := bfs_net_ok_level_gt_zero _ H_ok _ H_in'.
  case: H_q' => H_q'.
    injection H_q' => H_eq H_eq'.
    suff H_suff: 0 > 0 by contradict H_suff; auto with arith.
    apply: H_lv'.
    by rewrite -H_eq.
  exact: H_bef.
Qed.

Lemma bfs_net_ok_find_level_0_then_root : forall (T5 : T), bfs_net_ok T5 ->
  forall (t5 : t), In t5 T5 ->
  forall (j : i), IMap.find j (bfs_levels t5) = Some 0 ->
  j = 0.
Proof.
move => T5 H_ok t5 H_in.
pose P_curr (t5 : t) := forall (j : i), IMap.find j (bfs_levels t5) = Some 0 -> j = 0.
rewrite -/(P_curr _).
apply (P_inv_bfs T5); rewrite /P_curr //= {H_ok T5 H_in t5 P_curr}.
- (* fail *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 H_find.
  have H_neq': j <> i6.
    move => H_eq.
    by rewrite H_eq IMapFacts.remove_eq_o in H_find.
  rewrite IMapFacts.remove_neq_o in H_find => //.
  exact: H_bef.
- (* fail *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 H_find.
  have H_neq': j <> i6.
    move => H_eq.
    by rewrite H_eq IMapFacts.remove_eq_o in H_find.
  rewrite IMapFacts.remove_neq_o in H_find => //.
  exact: H_bef.
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 H_find.
  case (eq_i j i6) => H_eq.
    rewrite H_eq IMapFacts.add_eq_o in H_find => //.
    injection H_find => H_eq'.
    rewrite H_eq' in H_fst.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    have H_in: In t_before (t_before :: T5) by left.
    have H_rt := bfs_net_ok_status_0_in_queue_then_root _ H_ok _ H_in _ H_fst.
    by rewrite -H_eq.
  rewrite IMapFacts.add_neq_o in H_find => //.
  exact: H_bef.
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 H_find.
  have H_neq': j <> i6.
    move => H_eq.
    by rewrite H_eq IMapFacts.remove_eq_o in H_find.
  rewrite IMapFacts.remove_neq_o in H_find => //.
  exact: H_bef.
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j lv5 H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 H_find.
  case (eq_i j i6) => H_eq.
    rewrite H_eq IMapFacts.add_eq_o in H_find => //.
    injection H_find => H_eq'.
    rewrite H_eq' in H_fst.
    apply first_firstin in H_fst.
    apply firstin_in_queue in H_fst.
    have H_in: In t_before (t_before :: T5) by left.
    have H_rt := bfs_net_ok_status_0_in_queue_then_root _ H_ok _ H_in _ H_fst.
    by rewrite -H_eq.
  rewrite IMapFacts.add_neq_o in H_find => //.
  exact: H_bef.
- (* status *)
  move => T5 i5 q5 I5 b5 L5 q' j H_fst H_deq H_lv H_neq.
  set t_before := mk_nd_bfs _ _ _ _ _.
  move => H_ok H_bef i6 H_find.
  have H_neq': j <> i6.
    move => H_eq.
    by rewrite H_eq IMapFacts.remove_eq_o in H_find.
  rewrite IMapFacts.remove_neq_o in H_find => //.
  exact: H_bef.
Qed.

Lemma only_one_new_per_ident_bfs : forall (T5 : T), bfs_net_ok T5 -> 
  forall (t5 : t), In t5 T5 -> 
  forall (q5 : q) (j : i),
  first (bfs_mbox t5) = Some (msg_new j) ->
  dequeue (bfs_mbox t5) = Some q5 ->
  ~ In_queue (msg_new j) q5.
Proof.
move => T5 H_ok.
apply project_churn_bfs_ok in H_ok.
case => i5 q5 I5 b5 L5 /=.
set t5 := mk_nd_bfs _ _ _ _ _.
move => H_in q' j.
set s5 := mk_nd_churn i5 (remove_except_new_fail q5) I5.
have H_in': In s5 (project_churn_bfs T5).
have [T' [T6 H_eq]] := in_split t5 T5 H_in.
  rewrite H_eq.
  rewrite project_churn_bfs_distr.
  apply in_or_app.
  by right; left.
have H_ex := only_one_new_per_ident_churn (project_churn_bfs _) H_ok s5 H_in'.
move => H_fst H_deq.
suff H_suff: ~ In_queue (msg_new j) (remove_except_new_fail q').
  move => H_q.
  case: H_suff.
  exact: filter_P_in_queue.
apply first_firstin in H_fst.
apply dequeue_dequeued in H_deq.
apply: H_ex.
  apply first_firstin.
  exact: filter_P_first.
apply dequeue_dequeued.
move: H_deq H_fst.
exact: dequeued_filter_P.
Qed.
  
End GAPNGBfsSafety.
